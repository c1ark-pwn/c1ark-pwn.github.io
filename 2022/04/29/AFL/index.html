<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml" />



  <meta name="keywords" content="fuzz," />










<meta name="description" content="AFL简单使用安装和使用区分大小写的文件夹喔 官网下载：https:&#x2F;&#x2F;lcamtuf.coredump.cx&#x2F;afl&#x2F; 有源码的程序正常编译安装 1234567# 安装makesudo make install# 对源码插桩 并进行编译测试afl-gcc -g -o afl_test afl_test.cafl-fuzz -i fuzz_in -o fuzz_out .&#x2F;afl_test   无">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL源码阅读和实战初探">
<meta property="og:url" content="http://example.com/2022/04/29/AFL/index.html">
<meta property="og:site_name" content="C1arkesのblog">
<meta property="og:description" content="AFL简单使用安装和使用区分大小写的文件夹喔 官网下载：https:&#x2F;&#x2F;lcamtuf.coredump.cx&#x2F;afl&#x2F; 有源码的程序正常编译安装 1234567# 安装makesudo make install# 对源码插桩 并进行编译测试afl-gcc -g -o afl_test afl_test.cafl-fuzz -i fuzz_in -o fuzz_out .&#x2F;afl_test   无">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/photo/image-20220326222306971.png">
<meta property="og:image" content="http://example.com/photo/779730_GXSEXM24ZC32HRF.jpg">
<meta property="og:image" content="http://example.com/photo/779730_WNCMH89CW5PFWMW.jpg">
<meta property="article:published_time" content="2022-04-29T00:51:32.000Z">
<meta property="article:modified_time" content="2022-04-29T00:52:52.416Z">
<meta property="article:author" content="C1arkes">
<meta property="article:tag" content="fuzz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/photo/image-20220326222306971.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2022/04/29/AFL/"/>





  <title>AFL源码阅读和实战初探 | C1arkesのblog</title>
  








<meta name="generator" content="Hexo 6.1.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">C1arkesのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/AFL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/c1arkes-head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="C1arkesのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">AFL源码阅读和实战初探</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-29T08:51:32+08:00">
                2022-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/fuzz/" itemprop="url" rel="index">
                    <span itemprop="name">fuzz</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="AFL简单使用"><a href="#AFL简单使用" class="headerlink" title="AFL简单使用"></a>AFL简单使用</h1><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>区分大小写的文件夹喔</p>
<p>官网下载：<a target="_blank" rel="noopener" href="https://lcamtuf.coredump.cx/afl/">https://lcamtuf.coredump.cx/afl/</a></p>
<p>有源码的程序正常编译安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对源码插桩 并进行编译测试</span></span><br><span class="line">afl-gcc -g -o afl_test afl_test.c</span><br><span class="line">afl-fuzz -i fuzz_in -o fuzz_out ./afl_test </span><br></pre></td></tr></table></figure>

<p>无源码的程序还需要安装qemu-mode</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 qemu-mode</span></span><br><span class="line">sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y</span><br><span class="line">cd ~/tools/afl-2.52b/qemu_mode</span><br><span class="line">./build_qemu_support.sh</span><br><span class="line">cd ../</span><br><span class="line">make install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用qemu对二进制程序进行fuzz</span></span><br><span class="line">gcc -g -o afl_test2 afl_test.c</span><br><span class="line">afl-fuzz -i fuzz_in -o fuzz_out -Q ./afl_test2</span><br></pre></td></tr></table></figure>

<p>安装llvm-mode</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ./llvm-mode</span><br><span class="line">make</span><br><span class="line">cd ../</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>



<p>afl_test.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>) &#123;</span><br><span class="line">        raise(SIGSEGV); <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>) &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下图中的字段详情：<a target="_blank" rel="noopener" href="https://lcamtuf.coredump.cx/afl/status_screen.txt">https://lcamtuf.coredump.cx/afl/status_screen.txt</a></p>
<ul>
<li>Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。</li>
<li>Overall results：Fuzzer当前状态的概述。</li>
<li>Cycle progress：我们输入队列的距离。</li>
<li>Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。</li>
<li>Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。</li>
<li>Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。</li>
<li>Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。</li>
<li>Path geometry：有关Fuzzer找到的执行路径的信息。</li>
<li>CPU load：CPU利用率</li>
</ul>
<p><img src="/photo/image-20220326222306971.png" alt="image-20220326222306971"></p>
<p>输出目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── crashes</span><br><span class="line">│   ├── README.txt</span><br><span class="line">│   ├── id:000000,sig:06,src:000000,op:havoc,rep:64</span><br><span class="line">│   ├── id:000001,sig:06,src:000001,op:havoc,rep:8</span><br><span class="line">│   ├── id:000002,sig:06,src:000002,op:havoc,rep:4</span><br><span class="line">│   └── id:000003,sig:11,src:000002,op:havoc,rep:4</span><br><span class="line">├── fuzz_bitmap</span><br><span class="line">├── fuzzer_stats</span><br><span class="line">├── hangs</span><br><span class="line">├── plot_data</span><br><span class="line">└── queue</span><br><span class="line">    ├── id:000000,orig:testcase</span><br><span class="line">    ├── id:000001,src:000000,op:flip1,pos:0,+cov</span><br><span class="line">    └── id:000002,src:000000,op:arith8,pos:0,val:-27,+cov</span><br></pre></td></tr></table></figure>

<p><code>queue</code>：存放所有具有独特执行路径的测试用例。<br><code>crashes</code>：导致目标接收致命<code>signal</code>而崩溃的独特测试用例。<br><code>crashes/README.txt</code>：保存了目标执行这些<code>crash</code>文件的命令行参数。<br><code>hangs</code>：导致目标超时的独特测试用例。<br><code>fuzzer_stats</code>：<code>afl-fuzz</code>的运行状态。<br><code>plot_data</code>：用于<code>afl-plot</code>绘图。</p>
<h1 id="AFL实战"><a href="#AFL实战" class="headerlink" title="AFL实战"></a>AFL实战</h1><h2 id="yaml-cpp-项目"><a href="#yaml-cpp-项目" class="headerlink" title="yaml-cpp 项目"></a>yaml-cpp 项目</h2><p>参考： <a target="_blank" rel="noopener" href="https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/">https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/</a></p>
<h3 id="YAML-插桩"><a href="#YAML-插桩" class="headerlink" title="YAML 插桩"></a>YAML 插桩</h3><p>YAML是一个可读性高，用来表达数据序列化的格式。</p>
<p>让我们获取 yaml-cpp 代码库并使用 AFL 构建它</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/jbeder/yaml-cpp.git</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> yaml-cpp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> build</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake -DCMAKE_CXX_COMPILER=afl-clang-fast++ ..</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure>

<p>编译完成的二进制文件位于<code>build/util</code>下</p>
<p>在 &#x2F;util&#x2F;parse.cpp 中，我们可以使用 AFL 技巧更新 main() 函数以实现持久模式，更新如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  std::ifstream fin;</span><br><span class="line">  fin.<span class="built_in">open</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">parse</span>(fin);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">    <span class="built_in">parse</span>(std::cin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们重新编译。切换回 yaml-cpp 根目录中的 build 目录，然后键入“make”以重建 parse.cpp</p>
<h3 id="测试二进制文件"><a href="#测试二进制文件" class="headerlink" title="测试二进制文件"></a>测试二进制文件</h3><p>编译完二进制文件后，我们可以使用 AFL 附带的名为 afl-showmap 的工具对其进行测试。afl-showmap 工具将运行给定的检测二进制文件（将通过标准输入接收到的任何输入通过标准输入传递给检测二进制文件）并打印它在程序执行期间看到的反馈报告。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/yaml-cpp/build/util$ afl-showmap -o /dev/null -- ./parse &lt; &lt;(echo hi)</span><br><span class="line">afl-showmap 2.57b by &lt;lcamtuf@google.com&gt;</span><br><span class="line">[*] Executing &#x27;./parse&#x27;...</span><br><span class="line"></span><br><span class="line">-- Program output begins --</span><br><span class="line">hi</span><br><span class="line">-- Program output ends --</span><br><span class="line">[+] Captured 3707 tuples in &#x27;/dev/null&#x27;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/yaml-cpp/build/util$ afl-showmap -o /dev/null -- ./parse &lt; &lt;(echo hi: blah)</span><br><span class="line">afl-showmap 2.57b by &lt;lcamtuf@google.com&gt;</span><br><span class="line">[*] Executing &#x27;./parse&#x27;...</span><br><span class="line"></span><br><span class="line">-- Program output begins --</span><br><span class="line">hi: blah</span><br><span class="line">-- Program output ends --</span><br><span class="line">[+] Captured 4722 tuples in &#x27;/dev/null&#x27;.</span><br></pre></td></tr></table></figure>

<p>如您所见，发送一个简单的 YAML 键 (hi) 只表达了 3707个反馈元组，但一个带有值的 YAML 键 (hi: blah) 表达了 4722个反馈元组。我们应该很好地使用检测的二进制文件，现在我们需要测试用例来为我们的 fuzzing 提供种子。</p>
<h3 id="高质量的测试用例"><a href="#高质量的测试用例" class="headerlink" title="高质量的测试用例"></a>高质量的测试用例</h3><p>如前所述，yaml-cpp 测试目录中的 <code>test/specexamples.h</code> 文件有很好的测试用例供我们开始，但它们可以更好。AFL 附带了两个工具，我们可以用来确保：</p>
<ul>
<li>测试语料库中的文件尽可能高效地唯一</li>
<li>每个测试文件都尽可能高效地表达其独特的代码路径</li>
</ul>
<p><strong>afl-cmin</strong> 获取一个给定的潜在测试用例文件夹，然后运行每个测试用例并将它收到的反馈与所有其他测试用例进行比较，以找到最适合的测试用例有效地表达<strong>最独特的代码路径</strong>。最好的测试用例被保存到一个新目录。</p>
<p>另一方面，<strong>afl-tmin</strong> 工具仅适用于指定的文件。当我们进行模糊测试时，我们不想浪费 CPU 周期来摆弄相对于测试用例可能表达的代码路径而言<strong>无用的位和字节</strong>。为了将每个测试用例最小化到表达与原始测试用例相同的代码路径所需的最低限度，afl-tmin 迭代测试用例中的实际字节，逐渐删除越来越小的数据块，直到它删除任何字节不要影响所采用的代码路径。这有点多，但这些是有效模糊测试的非常重要的步骤，它们是需要理解的重要概念。让我们看一个例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/yaml-seed$ afl-tmin -i 8 -o 8.min -- ../yaml-cpp/build/util/parse</span><br><span class="line">afl-tmin 2.57b by &lt;lcamtuf@google.com&gt;</span><br><span class="line"></span><br><span class="line">[+] Read 125 bytes from &#x27;8&#x27;.</span><br><span class="line">[*] Performing dry run (mem limit = 50 MB, timeout = 1000 ms)...</span><br><span class="line">[+] Program terminates normally, minimizing in instrumented mode.</span><br><span class="line">[*] Stage #0: One-time block normalization...</span><br><span class="line">[+] Block normalization complete, 77 bytes replaced.</span><br><span class="line">[*] --- Pass #1 ---</span><br><span class="line">[*] Stage #1: Removing blocks of data...</span><br><span class="line">    Block length = 8, remaining size = 125</span><br><span class="line">    Block length = 4, remaining size = 72</span><br><span class="line">    Block length = 2, remaining size = 68</span><br><span class="line">    Block length = 1, remaining size = 68</span><br><span class="line">[+] Block removal complete, 57 bytes deleted.</span><br><span class="line">[*] Stage #2: Minimizing symbols (20 code points)...</span><br><span class="line">[+] Symbol minimization finished, 14 symbols (20 bytes) replaced.</span><br><span class="line">[*] Stage #3: Character minimization...</span><br><span class="line">[+] Character minimization done, 0 bytes replaced.</span><br><span class="line">[*] --- Pass #2 ---</span><br><span class="line">[*] Stage #1: Removing blocks of data...</span><br><span class="line">    Block length = 4, remaining size = 68</span><br><span class="line">    Block length = 2, remaining size = 68</span><br><span class="line">    Block length = 1, remaining size = 68</span><br><span class="line">[+] Block removal complete, 0 bytes deleted.</span><br><span class="line"></span><br><span class="line">     File size reduced by : 45.60% (to 68 bytes)</span><br><span class="line">    Characters simplified : 142.65%</span><br><span class="line">     Number of execs done : 258</span><br><span class="line">          Fruitless execs : path=215 crash=0 hang=0</span><br><span class="line"></span><br><span class="line">[*] Writing output to &#x27;8.min&#x27;...</span><br><span class="line">[+] We&#x27;re done here. Have a nice day!</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/yaml-seed$ cat 8</span><br><span class="line">---</span><br><span class="line">time: 20:03:20</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: strike (miss)</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">time: 20:03:47</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: grand slam</span><br><span class="line">...</span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/yaml-seed$ cat 8.min</span><br><span class="line">---</span><br><span class="line">0000: 00:00:00</span><br><span class="line">000000: 00000 0000</span><br><span class="line">000000: 000000 000000</span><br><span class="line">...</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>得到的<code>*.min</code>则是用来测试的用例。当然我们还可以利用字典标记功能来使用 YAML 特殊字符为 AFL 播种以增加更多效力。</p>
<h3 id="启动fuzz"><a href="#启动fuzz" class="headerlink" title="启动fuzz"></a>启动fuzz</h3><p>AFL 有两种模糊测试策略，一种是确定性的，另一种是随机的和混乱的。一般来说，您只需要一个确定性（或主）模糊器，但您可以拥有尽可能多的随机（或从属）模糊器。如果没有指定 fuzzing 策略，则 afl-fuzz 实例将在每个策略之间来回切换。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在不同的终端</span></span><br><span class="line">afl-fuzz -i input_dir/ -o output_dir/ -M fuzzer1 -- ./yaml-cpp/build/util/parse</span><br><span class="line">afl-fuzz -i input_dir/ -o output_dir/ -S fuzzer2 -- ./yaml-cpp/build/util/parse</span><br></pre></td></tr></table></figure>

<p>要注意每个命令中使用的参数 -M 和 -S。通过将 -M fuzzer1 传递给 afl-fuzz，我告诉它是一个 Master fuzzer（使用确定性策略），并且 fuzz 实例的名称是 fuzzer1。另一方面，传递给第二个命令的 -S fuzzer2 表示使用随机、混乱的策略和名称为 fuzzer2 运行实例。这两个 fuzzer 将相互协作，在找到新的代码路径时相互传递新的测试用例。</p>
<h3 id="何时停止和整理"><a href="#何时停止和整理" class="headerlink" title="何时停止和整理"></a>何时停止和整理</h3><p>一旦 yaml-cpp 解析二进制文件的 Master fuzzer 完成了它的第一个周期（对我来说大约需要 10 个小时，对于普通工作站来说可能需要 24 个小时），我们可以继续并停止我们的 afl-fuzz 实例。我们需要<strong>整合并最小化</strong>每个实例的队列，然后再次重新启动模糊测试。每个单独的 fuzzer syncdir 都包含一个队列目录，其中包含 AFL 能够生成的所有测试用例，这些测试用例导致新的代码路径值得一试。<strong>我们需要合并每个模糊实例的队列目录，因为会有很多重叠，然后最小化这个新的测试数据体。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/output_dir$ cd output_dir ; ls</span><br><span class="line">fuzzer1 fuzzer2</span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/output_dir$ mkdir queue_all</span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/output_dir$ cp fuzzer*/queue/* queue_all/</span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/output_dir$ afl-cmin -i queue_all/ -o queue_cmin -- ../yaml-cpp/build/util/parse</span><br><span class="line">corpus minimization tool for afl-fuzz by &lt;lcamtuf@google.com&gt;</span><br><span class="line"></span><br><span class="line">[*] Testing the target binary...</span><br><span class="line">[+] OK, 5525 tuples recorded.</span><br><span class="line">[*] Obtaining traces for input files in &#x27;queue_all/&#x27;...</span><br><span class="line">    Processing file 3445/3445...</span><br><span class="line">[*] Sorting trace sets (this may take a while)...</span><br><span class="line">[+] Found 46200 unique tuples across 3445 files.</span><br><span class="line">[*] Finding best candidates for each tuple...</span><br><span class="line">    Processing file 3445/3445...</span><br><span class="line">[*] Sorting candidate list (be patient)...</span><br><span class="line">[*] Processing candidates and writing output files...</span><br><span class="line">    Processing tuple 46200/46200...</span><br><span class="line">[+] Narrowed down to 729 files, saved in &#x27;queue_cmin&#x27;.</span><br></pre></td></tr></table></figure>

<p>一旦我们通过 afl-cmin 运行了生成的队列，我们需要最小化每个生成的文件，这样我们就不会在不需要的字节上浪费 CPU 周期。然后可以使用<code>afl-tmin</code>缩减数据块的大小，删除无用的位和字节，进行最小化操作。</p>
<h3 id="重新开始"><a href="#重新开始" class="headerlink" title="重新开始"></a>重新开始</h3><p>随着新的最小化队列到位，我们可以开始从我们离开的地方开始模糊测试。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/output_dir$ ls</span><br><span class="line">fuzzer1  fuzzer2  queue_all  queue_cmin</span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/output_dir$ rm -rf ./fuzzer*/queue</span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/output_dir$ cp -r queue_cmin/ ./fuzzer1/queue</span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/output_dir$ cp -r queue_cmin/ ./fuzzer2/queue</span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice/output_dir$ cd ..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在不同的终端</span></span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice$ afl-fuzz -i- -o output_dir/ -M fuzzer1 -- ./yaml-cpp/build/util/parse</span><br><span class="line">clarkes@LAPTOP-OK4IE8JL:~/fuzz/practice$ afl-fuzz -i- -o output_dir/ -S fuzzer2 -- ./yaml-cpp/build/util/parse</span><br></pre></td></tr></table></figure>

<p>如果你注意到了，这次调用 afl-fuzz 时，我们没有传递 -i 参数来读取测试用例的目录，而是传递一个连字符。这告诉 AFL 只使用该 fuzzer 的 syncdir 中的 queue&#x2F; 目录作为种子目录并从那里开始备份。</p>
<h1 id="AFL源码阅读"><a href="#AFL源码阅读" class="headerlink" title="AFL源码阅读"></a>AFL源码阅读</h1><h2 id="afl-gcc-c"><a href="#afl-gcc-c" class="headerlink" title="afl-gcc.c"></a>afl-gcc.c</h2><p><code>afl-gcc</code>的功能就是找到<code>afl-as</code>所在的位置，然后设置必要的编译器参数和一些宏，然后调用对应编译器进行实际的编译，仅仅只是一层wrapper。</p>
<h3 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h3><p>gdb_afl_gcc.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb afl-gcc -q \</span><br><span class="line">    -ex &quot;b edit_params&quot; \</span><br><span class="line">    -ex &quot;run -g -o afl_test afl_test.c&quot; </span><br></pre></td></tr></table></figure>



<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isatty 判断文件描述符2是否是终端，终端返回1</span></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>; <span class="comment">// 启用quiet模式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印函数</span></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定as汇编器位置</span></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对参数进行解析和添加必要的参数</span></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(cc_params);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tag%d: %s\n&quot;</span>,i,cc_params[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc -g -o afl_test afl_test.c</span><br><span class="line">argc = 5</span><br><span class="line">argv[0] = &quot;/usr/local/bin/afl-gcc&quot;</span><br><span class="line">argv[1] = &quot;-g&quot;</span><br><span class="line">argv[2] = &quot;-o&quot;</span><br><span class="line">argv[3] = &quot;afl_test&quot;</span><br><span class="line">argv[4] = &quot;afl_test.c&quot;</span><br></pre></td></tr></table></figure>

<p>主要有3个函数：</p>
<ol>
<li><code>find_as(argv[0]);</code></li>
<li><code>edit_params(argc, argv)</code></li>
<li><code>execvp(cc_params[0], (char**)cc_params);</code></li>
</ol>
<h3 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h3><p>这个函数用来寻找<code>afl-as</code>的位置并将其所在的文件目录路径赋值给<code>as_path</code>变量</p>
<ul>
<li>它首先检查是否存在<code>AFL_PATH</code>这个环境变量，如果存在就赋值给<code>afl_path</code>，然后检查<code>afl_path/as</code>这个文件是否可以访问并且执行，如果可以，就将<code>as_path</code>设置为<code>afl_path</code>。</li>
<li>如果不存在<code>AFL_PATH</code>这个环境变量，则检查argv0，例如（”&#x2F;usr&#x2F;local&#x2F;bin&#x2F;afl-gcc”）中是否存在’&#x2F;‘，如果有就找到最后一个’&#x2F;‘所在的位置，并取其前面的字符串作为<code>dir</code>，然后检查<code>dir/afl-as</code>这个文件是否可以访问并且执行，如果可以，就将<code>as_path</code>设置为<code>dir</code>。</li>
<li>是否存在<code>AFL_PATH</code>宏，该宏在编译时由Makefile传递，检查<code>AFL_PATH/as</code>这个文件是否可以访问并且执行，如果可以，就将<code>as_path</code>设置为<code>AFL_PATH</code>宏。</li>
<li>如果上述三种方式都失败，则抛出异常。</li>
</ul>
<h3 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h3><p>这个函数用来将<code>argv</code>进行解析和补充，并且做一些必要的修改然后保存为<code>cc_params</code>参数。以便接下来的<code>execvp</code>函数的执行。</p>
<ul>
<li><p>它首先通过<code>ck_alloc</code>来为<code>cc_params</code>分配内存，分配的长度为<code>(argc+128)*8</code>，相当大的内存了。</p>
</li>
<li><p>然后检查<code>argv[0]</code>，例如:<code>argv[0] = &#39;/usr/local/bin/afl-gcc&#39;</code>，将最后一个<code>&#39;/&#39;</code>后的字符串，即编译器名字赋值给<code>name</code>。</p>
</li>
<li><p>将<code>name</code>和<code>afl-clang</code>比较</p>
<ul>
<li><p>如果相同，则设置<code>clang_mode = 1</code>，然后设置环境变量<code>CLANG_ENV_VAR</code>为1。</p>
<ul>
<li>然后将<code>name</code>和<code>afl-clang++</code>比较<ul>
<li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将<code>cc_params[0]</code>设置为该值，如果不存在，就设置为<code>clang++</code></li>
<li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将<code>cc_params[0]</code>设置为该值，如果不存在，就设置为<code>clang</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>将<code>name</code>和<code>afl-g++</code>比较</p>
<ul>
<li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将<code>cc_params[0]</code>设置为该值，如果不存在，就设置为<code>g++</code></li>
<li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将<code>cc_params[0]</code>设置为该值，如果不存在，就设置为<code>gcc</code></li>
</ul>
</li>
<li><p>确定了编译器后<strong>遍历</strong>从<code>argv[1]</code>开始的<code>argv</code>参数，遍历过程如下：</p>
<ul>
<li><code>cur = *(++argv)</code></li>
<li>跳过<code>-B/-integrated-as/-pipe</code></li>
<li>如果存在<code>-fsanitize=address</code>或者<code>-fsanitize=memory</code>，就设置<code>asan_set = 1</code></li>
<li>如果存在<code>FORTIFY_SOURCE</code>，则设置<code>fortify_set = 1</code></li>
<li><code>cc_params[cc_par_cnt++] = cur</code>，<code>cc_par_cnt</code>的初始值为1</li>
</ul>
</li>
<li><p>遍历结束后开始设置其他的<code>cc_params</code>参数</p>
<ul>
<li>取之前计算出来的<code>as_path</code>，然后设置<code>-B as_path</code></li>
<li>如果<code>clang_mode = 1</code>,则设置<code>-no-integrated-as</code></li>
<li>如果存在<code>AFL_HARDEN</code>环境变量<ul>
<li>则设置<code>-fstack-protector-all</code></li>
<li><code>fortify_set</code>未被设置，设置<code>-D_FORTIFY_SOURCE=2</code></li>
</ul>
</li>
<li>sanitizer (设置<code>AFL_USE_ASAN</code>或者<code>AFL_USE_MSAN</code>环境变量，并不影响后续，只是在设置编译参数时有一点差别)<ul>
<li>如果<code>asan_set</code>在上面被设置为1，则使<code>AFL_USE_ASAN</code>环境变量为1</li>
<li>如果存在<code>AFL_USE_ASAN</code>环境变量，则设置<code>-U_FORTIFY_SOURCE -fsanitize=address</code>，即取消<code>_FORTIFY_SOURCE</code>的宏定义，并且设置快速内存错误检测器。</li>
<li>如果存在<code>AFL_USE_MSAN</code>环境变量，则设置<code>-U_FORTIFY_SOURCE -fsanitize=memory</code>，但不能同时还指定<code>AFL_HARDEN</code>或者<code>AFL_USE_ASAN</code>，因为这样运行时速度过慢。</li>
</ul>
</li>
<li>如果不存在<code>AFL_DONT_OPTIMIZE</code>环境变量<br>则设置<code>-g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></li>
<li>如果存在<code>AFL_NO_BUILTIN</code>环境变量，则设置<code>-fno-builtin-strcmp</code>等取消内置的一些字符串处理函数。</li>
</ul>
</li>
<li><p>最后<code>cc_params[cc_par_cnt] = NULL;</code>终止对<code>cc_params</code>的编辑。</p>
</li>
</ul>
<h3 id="execvp"><a href="#execvp" class="headerlink" title="execvp"></a>execvp</h3><p>根据上述运行参数生成的<code>cc_params</code>，作为参数执行<code>execvp</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cc_params[0] = &quot;gcc&quot;</span><br><span class="line">cc_params[1] = &quot;-g&quot;</span><br><span class="line">cc_params[2] = &quot;-o&quot;</span><br><span class="line">cc_params[3] = &quot;afl_test&quot;</span><br><span class="line">cc_params[4] = &quot;afl_test.c&quot;</span><br><span class="line">cc_params[5] = &quot;-B&quot;</span><br><span class="line">cc_params[6] = &quot;/usr/local/lib/afl&quot;</span><br><span class="line">cc_params[7] = &quot;-g&quot;</span><br><span class="line">cc_params[8] = &quot;-O3&quot; # 优化等级</span><br><span class="line">cc_params[9] = &quot;-funroll-loops&quot;</span><br><span class="line">cc_params[10] = &quot;-D__AFL_COMPILER=1&quot; </span><br><span class="line">cc_params[11] = &quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span><br></pre></td></tr></table></figure>



<h2 id="afl-as-c"><a href="#afl-as-c" class="headerlink" title="afl-as.c"></a>afl-as.c</h2><p>对.s文件进行分析，并且在适当位置插入汇编代码来完成插桩操作。</p>
<h3 id="调试脚本-1"><a href="#调试脚本-1" class="headerlink" title="调试脚本"></a>调试脚本</h3><p>gdb_afl_as.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">gdb afl-gcc -q \</span><br><span class="line">    -ex &quot;catch exec&quot; \</span><br><span class="line">    -ex &quot;run -g -o afl_test afl_test.c&quot; \</span><br><span class="line">    -ex &quot;b execv&quot; \</span><br><span class="line">    -ex &quot;b execvp&quot; \</span><br><span class="line">    -ex &quot;set follow-fork-mode parent&quot; \</span><br><span class="line">    -ex &quot;b *0x4675FE&quot; \</span><br><span class="line">    -ex &quot;c&quot; \</span><br><span class="line">    -ex &quot;set follow-fork-mode child&quot; \</span><br><span class="line">    -ex &quot;delete&quot; \</span><br><span class="line">    -ex &quot;catch exec&quot; \</span><br><span class="line">    -ex &quot;c&quot; \</span><br><span class="line">    -ex &quot;b edit_params&quot; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc 中用子进程依次执行 cc1 as ld</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第6行设置跟踪父进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第7行 到达断点时gcc已经启动子进程执行cc1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第9行 设置回来跟踪子进程 as 即 afl-as</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> follow-fork-mode child</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> follow-fork-mode parent</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">delete</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">catch <span class="built_in">exec</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">run arg1 arg2</span></span><br></pre></td></tr></table></figure>



<h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="comment">// 该环境变量主要控制检测每个分支的概率，取值为0到100%，设置为0时则只检测函数入口的跳转，而不会检测函数分支的跳转</span></span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取时区</span></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);</span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</span><br><span class="line">  <span class="comment">// 设置随机数种子</span></span><br><span class="line">  srandom(rand_seed);</span><br><span class="line">  <span class="comment">// 进行参数处理</span></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  <span class="comment">// 检查inst_ratio_str的合法值</span></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>) </span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))</span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置环境变量 AFL_LOOP_ENV_VAR</span></span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line">  <span class="comment">// 插桩率除于3</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;</span><br><span class="line">    inst_ratio /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// add_instrumentation 函数负责处理输入文件，生成 modified_file ，将 instrumentation 插入所有适当的位置</span></span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();</span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line">    <span class="comment">// 子进程 汇编器</span></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);</span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);</span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要函数和变量：</p>
<ul>
<li>变量<ol>
<li><code>as_params</code></li>
<li><code>input_file</code></li>
<li><code>modified_file</code></li>
<li><code>trampoline_fmt_64 / trampoline_fmt_32</code></li>
<li><code>main_payload_64 / main_payload_32</code></li>
</ol>
</li>
<li>函数<ol>
<li><code>edit_params(argc, argv)</code></li>
<li><code>add_instrumentation()</code> 实现插桩的核心函数。<br>插入的汇编代码片段包括 <code>trampoline_fmt_64 / trampoline_fmt_32</code> 以及<code>main_payload_64 / main_payload_32</code></li>
<li><code>execvp(as_params[0], (char**)as_params)</code></li>
</ol>
</li>
</ul>
<p>运行参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/afl/as --64 -o /tmp/ccZtoevv.o /tmp/ccFadyfG.s</span><br></pre></td></tr></table></figure>



<h3 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h3><p>这个函数用来将<code>argv</code>进行解析和补充，并且做一些必要的修改然后保存为<code>as_params</code>参数。以便接下来的<code>execvp</code>函数的执行。</p>
<ul>
<li><p>首先确定<code>tmp_dir</code>和<code>afl_as</code>的值。</p>
<ul>
<li>依次检查是否存在<code>TMPDIR/TEMP/TMP</code>环境变量，如果存在就设置，如果都不存在就设置<code>tmp_dir</code>为<code>/tmp</code></li>
<li>读取<code>AFL_AS</code>环境变量，如果存在就设置为<code>afl_as</code>的值</li>
</ul>
</li>
<li><p>为<code>as_params</code>分配空间，大小为<code>(argc+32)*8</code></p>
</li>
<li><p>如果<code>afl_as</code>不为空，就设置<code>as_params[0]</code>为<code>afl_as</code>，否则设置为<code>&quot;as&quot;</code></p>
</li>
<li><p>设置<code>as_params[argc] = 0</code></p>
</li>
<li><p>然后遍历从<code>argv[1]</code>开始,到<code>argv[argc-1]</code>即<code>1 &lt;= i &lt;= argc-1</code></p>
<ul>
<li>如果存在<code>--64</code>参数，设置<code>use_64bit = 1</code>，如果存在<code>--32</code>参数，设置<code>use_64bit = 0</code></li>
<li><code>as_params[as_par_cnt++] = argv[i]</code>，<code>as_par_cnt</code>初始值为1</li>
</ul>
</li>
<li><p>然后开始设置其他的<code>as_params</code>参数</p>
<ul>
<li><p>读取<code>argv[argc-1]</code>的值,赋给<code>input_file</code>的值,也就是传递的最后一个参数的值作为<code>input_file</code><br>例如<code>input_file = &quot;/tmp/ccFadyfG.s&quot;</code></p>
</li>
<li><p>满足下面条件就设置<code>pass_thru = 1</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>modified_file</code>的值为<code>alloc_printf(&quot;%s/.afl-%u-%u.s&quot;, tmp_dir, getpid(),(u32) time(NULL));</code>,简单的说就是<code>tmp_dir/.afl-pid-time.s</code>这样的字符串。例如<code>modified_file = &quot;/tmp/.afl-22940-1648484065.s&quot;</code></p>
</li>
<li><p>设置<code>as_params[as_par_cnt++] = modified_file</code></p>
</li>
<li><p><code>as_params[as_par_cnt] = NULL</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h3><p>实现核心内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*	   If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class="line"><span class="comment">       names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class="line"><span class="comment">       we want to catch:</span></span><br><span class="line"><span class="comment">		即在这些地方进行插桩</span></span><br><span class="line"><span class="comment">         ^function:  - function entry point (always instrumented)</span></span><br><span class="line"><span class="comment">         ^.L&lt;num&gt;:       - GCC branch label</span></span><br><span class="line"><span class="comment">         ^.LBB&lt;num&gt;:   - clang branch label (but only in clang mode)</span></span><br><span class="line"><span class="comment">         ^\tjnz foo  - conditional branches</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...but not:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^# BB#0:    - clang comments</span></span><br><span class="line"><span class="comment">         ^ # BB#0:   - ditto</span></span><br><span class="line"><span class="comment">         ^.Ltmp0:    - clang non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LC0       - GCC non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class="line"><span class="comment">         ^\tjmp foo  - non-conditional jumps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class="line"><span class="comment">       with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class="line"><span class="comment">       later on.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>首先打开<code>input_file</code>和<code>modified_file</code></p>
</li>
<li><p>进入<code>while</code>循环，每一次循环都从<code>input_file</code>中读取一行放到<code>line</code>中。</p>
<ul>
<li><p>判断<code>instr_ok &amp;&amp; instrument_next &amp;&amp; line[0] == &#39;\t&#39; &amp;&amp; isalpha(line[1])</code></p>
<ul>
<li>即判断<code>instrument_next</code>和<code>instr_ok</code>是否都为1，以及<code>line</code>是否以<code>\t</code>开始，且<code>line[1]</code>是否是字母</li>
<li>如果都满足，则设置<code>instrument_next = 0</code>,并向<code>modified_file</code>中写入<code>trampoline_fmt</code>，并将插桩计数器<code>ins_lines</code>加一。</li>
<li>这其实是因为我们想要插入instrumentation trampoline到所有的标签，宏，注释之后。</li>
</ul>
</li>
<li><p>首先要设置<code>instr_ok</code>的值，这个值其实是一个flag，只有这个值被设置为1，才代表我们在<code>.text</code>部分，否则就不在。于是如果<code>instr_ok = 1</code>，就会在分支处执行插桩逻辑，否则就不插桩。</p>
<ul>
<li><p>如果<code>line</code>的值为<code>\t.[text\n|section\t.text|section\t__TEXT,__text|section __TEXT,__text]...</code>其中之一，则设置<code>instr_ok = 1</code>，然后<code>continue</code>进行下一个循环。</p>
</li>
<li><p>如果不是上面的几种情况，且<code>line</code>的值为<code>\t.[section\t|section |bss\n|data\n]...</code>，则设置<code>instr_ok = 0</code>，然后<code>continue</code>进行下一个循环。</p>
</li>
</ul>
</li>
<li><p>插桩<code>^\tjnz foo</code>条件跳转指令</p>
<ul>
<li>如果<code>line</code>的值为<code>\tj[!m]...</code>,且<code>R(100) &lt; inst_ratio</code>，R(100)会返回一个100以内的随机数，inst_ratio是我们之前设置的插桩密度，默认为100，如果设置了asan之类的就会默认设置成30左右。</li>
<li><code>fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</code></li>
<li>根据<code>use_64bit</code>来判断向outfd里写入<code>trampoline_fmt_64</code>还是<code>trampoline_fmt_32</code>。</li>
<li><code>define R(x) (random() % (x))</code>，可以看到R(x)是创建的随机数除以x取余，所以可能产生碰撞</li>
<li>这里的R(x)实际上是用来区分每个桩的，也就是是一个标识。后文会再说明。</li>
<li>将插桩计数器<code>ins_lines++</code>。</li>
</ul>
</li>
<li><p>检查<code>line</code>中是否存在<code>:</code>，然后检查是否以<code>.</code>开始</p>
<ul>
<li>如果以<code>.</code>开始，则判断是否想要插桩<code>^.L&lt;num&gt;:</code>或者<code>^.LBB&lt;num&gt;:</code><ul>
<li><p><code>if(isdigit(line[2]) || (clang_mode &amp;&amp; !strncmp(line + 1, &quot;LBB&quot;, 3))) &amp;&amp; R(100) &lt; inst_ratio)</code></p>
</li>
<li><p><code>line[2]</code>是否为数字，即满足<code>^.L&lt;num&gt;:</code>的情况，或者<code>clang_mode = 1</code>且<code>line[1~3] = &quot;LBB&quot;</code>，满足<code>^.LBB&lt;num&gt;:</code>的情况</p>
</li>
<li><p>如果结果为真，则设置<code>instrument_next = 1</code></p>
</li>
<li><p>否则代表这是一个function，插桩<code>^func:</code> function entry point</p>
<ul>
<li>直接设置<code>instrument_next = 1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>结束<code>while</code>循环后，如果插桩计数器<code>ins_lines</code>不为0，就在完全拷贝<code>input_file</code>之后，依据架构，向<code>modified_file</code>中写入<code>main_payload_64</code>或者<code>main_payload_32</code>，然后关闭这两个文件。</p>
</li>
</ul>
<h3 id="execvp-1"><a href="#execvp-1" class="headerlink" title="execvp"></a>execvp</h3><p>根据上述运行参数生成的<code>as_params</code>，fork一个子进程然后<code>as_params</code>将作为参数执行<code>execvp</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as --64 -o /tmp/ccZtoevv.o /tmp/ccFadyfG.s</span><br></pre></td></tr></table></figure>



<h3 id="trampoline-fmt-64"><a href="#trampoline-fmt-64" class="headerlink" title="trampoline_fmt_64"></a>trampoline_fmt_64</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插桩代码 R(MAP_SIZE) 生成的随机数作为随机插桩id</span></span><br><span class="line"><span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span> <span class="comment">// rcx中为随机插桩id 由R(MAP_SIZE)生成</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="main-payload-64"><a href="#main-payload-64" class="headerlink" title="main_payload_64"></a>main_payload_64</h3><p>由于<code>main_payload_64</code>为汇编代码，使用ida反编译如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall _afl_maybe_log(__int64 a1, __int64 a2, __int64 a3, __int64 id)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// of</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// al</span></span><br><span class="line">  __int64 v6; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v7; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> *v9; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> *v11; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// edi</span></span><br><span class="line">  __int64 pid; <span class="comment">// rax</span></span><br><span class="line">  __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp-10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">char</span> id_1; <span class="comment">// [rsp+10h] [rbp-160h]</span></span><br><span class="line">  __int64 id_2; <span class="comment">// [rsp+18h] [rbp-158h]</span></span><br><span class="line">   </span><br><span class="line">  v5 = v4;</span><br><span class="line">  v6 = _afl_area_ptr; <span class="comment">// _afl_area_ptr 为共享内存地址</span></span><br><span class="line">  <span class="keyword">if</span> ( !_afl_area_ptr ) <span class="comment">// 未分配_afl_area_ptr</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_setup_failure ) <span class="comment">// _afl_setup_failure 表示是否setup失败</span></span><br><span class="line">      <span class="keyword">return</span> v5 + <span class="number">127</span>;</span><br><span class="line">    v6 = _afl_global_area_ptr; <span class="comment">// _afl_global_area_ptr 与 _afl_area_ptr 一样存放共享内存地址</span></span><br><span class="line">    <span class="keyword">if</span> ( _afl_global_area_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      _afl_area_ptr = _afl_global_area_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// _afl_area_ptr _afl_global_area_ptr 都是NULL</span></span><br><span class="line">      id_1 = v4;</span><br><span class="line">      id_2 = id;</span><br><span class="line">      v9 = getenv(<span class="string">&quot;__AFL_SHM_ID&quot;</span>); <span class="comment">// 获取共享内存的资源ID</span></span><br><span class="line">      <span class="keyword">if</span> ( !v9 || (v10 = atoi(v9), v11 = shmat(v10, <span class="number">0LL</span>, <span class="number">0</span>), v11 == (<span class="type">void</span> *)<span class="number">-1LL</span>) )</span><br><span class="line">      &#123;<span class="comment">// 获取共享内存的资源失败则返回并且 ++_afl_setup_failure</span></span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v5 = id_1;</span><br><span class="line">        <span class="keyword">return</span> v5 + <span class="number">127</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 存在共享内存空间</span></span><br><span class="line">      _afl_area_ptr = (__int64)v11;</span><br><span class="line">      _afl_global_area_ptr = v11;</span><br><span class="line">      v15 = (__int64)v11;</span><br><span class="line">      <span class="keyword">if</span> ( write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4uLL</span>) == <span class="number">4</span> )  <span class="comment">// afl_temp为缓冲区，199 和 198 文件描述符在通信，将本进程的信息发往199</span></span><br><span class="line">      &#123; <span class="comment">// forkserver 启动成功</span></span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = <span class="number">198</span>;</span><br><span class="line">          <span class="keyword">if</span> ( read(<span class="number">198</span>, &amp;_afl_temp, <span class="number">4uLL</span>) != <span class="number">4</span> ) <span class="comment">// 得到回应才能正式开始</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          LODWORD(pid) = fork();</span><br><span class="line">          <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !pid ) <span class="comment">// 子进程跳转到 __afl_fork_resume</span></span><br><span class="line">            <span class="keyword">goto</span> __afl_fork_resume;</span><br><span class="line">          _afl_fork_pid = pid;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_fork_pid, <span class="number">4uLL</span>);</span><br><span class="line">          v12 = _afl_fork_pid;</span><br><span class="line">          LODWORD(v14) = waitpid(_afl_fork_pid, &amp;_afl_temp, <span class="number">0</span>);<span class="comment">// 等待子进程结束回收</span></span><br><span class="line">          <span class="keyword">if</span> ( v14 &lt;= <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4uLL</span>);</span><br><span class="line">        &#125;                                       <span class="comment">// while end</span></span><br><span class="line">        _exit(v12);                             <span class="comment">// 父进程退出</span></span><br><span class="line">      &#125;</span><br><span class="line">__afl_fork_resume:                              <span class="comment">// 子进程</span></span><br><span class="line">      close(<span class="number">198</span>);</span><br><span class="line">      close(<span class="number">199</span>);</span><br><span class="line">      v6 = v15;</span><br><span class="line">      v5 = id_1;</span><br><span class="line">      id = id_2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// _afl_area_ptr ！= NULL 子进程记录插桩</span></span><br><span class="line">  v7 = _afl_prev_loc ^ id; <span class="comment">// index</span></span><br><span class="line">  _afl_prev_loc ^= v7;</span><br><span class="line">  _afl_prev_loc = (<span class="type">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>; <span class="comment">// id &gt;&gt; 1</span></span><br><span class="line">  ++*(_BYTE *)(v6 + v7);                        <span class="comment">// 插桩运行标志 (_afl_area_ptr + index)++</span></span><br><span class="line">  <span class="keyword">return</span> v5 + <span class="number">127</span>;<span class="comment">// 子进程继续返回运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="afl-clang-fast-c"><a href="#afl-clang-fast-c" class="headerlink" title="afl-clang-fast.c"></a>afl-clang-fast.c</h2><p>因为AFL对于上述通过<code>afl-as</code>来插桩这种做法已经属于不建议，并提供了更好的工具<code>afl-clang-fast</code>，通过llvm pass来插桩。<code>afl-clang-fast.c</code>这个文件其实是clang的一层wrapper，和之前的<code>afl-gcc</code>一样，只是定义了一些宏，和传递了一些参数给真正的clang。</p>
<p>gdb_afl_fast.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb afl-clang-fast -q \</span><br><span class="line">    -ex &quot;b edit_params&quot; \</span><br><span class="line">    -ex &quot;run -g -o afl_test afl_test.c&quot; </span><br></pre></td></tr></table></figure>



<h3 id="main-2"><a href="#main-2" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-clang-fast [tpcg] &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-clang-fast &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for clang, letting you recompile third-party code with the required runtime\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-clang-fast ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-clang-fast++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;In contrast to the traditional afl-clang tool, this version is implemented as\n&quot;</span></span><br><span class="line">         <span class="string">&quot;an LLVM pass and tends to offer improved performance with slow programs.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC and AFL_CXX. Setting\n&quot;</span></span><br><span class="line">         <span class="string">&quot;AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ANDROID__</span></span><br><span class="line">  find_obj(argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params)</span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要函数：</p>
<ol>
<li><code>find_obj(argv[0])</code></li>
</ol>
<ul>
<li>与afl-gcc.c中的find_as雷同，这个函数用来寻找<code>afl-llvm-rt.o / afl-llvm-pass.so</code>的位置并将其所在的<strong>文件目录</strong>路径赋值给<code>obj_path</code>变量</li>
</ul>
<ol start="2">
<li><code>edit_params(argc, argv)</code> <ul>
<li>这个函数用来将<code>argv</code>进行解析和补充，并且做一些必要的修改然后保存为<code>cc_params</code>参数。以便接下来的<code>execvp</code>函数的执行</li>
</ul>
</li>
<li><code>execvp(cc_params[0], (char**)cc_params)</code></li>
</ol>
<p>运行参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">first</span></span><br><span class="line">afl-clang-fast -g -o afl_test afl_test.c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">second</span></span><br><span class="line">clang -Xclang -load -Xclang /usr/local/lib/afl/afl-llvm-pass.so -Qunused-arguments -g -o afl_test afl_test.c \</span><br><span class="line">-g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 \</span><br><span class="line">-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 \</span><br><span class="line">-D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)\&quot;##SIG_AFL_PERSISTENT##\&quot;; __attribute__((visibility(\&quot;default\&quot;))) int _L(unsigned int) __asm__(\&quot;__afl_persistent_loop\&quot;); \</span><br><span class="line">-D__AFL_INIT()=do &#123; static volatile char *_A __attribute__((used));  _A = (char*)\&quot;##SIG_AFL_DEFER_FORKSRV##\&quot;; __attribute__((visibility(\&quot;default\&quot;))) void _I(void) __asm__(\&quot;__afl_manual_init\&quot;); _I(); &#125;</span><br></pre></td></tr></table></figure>



<h2 id="afl-llvm-pass-so-cc"><a href="#afl-llvm-pass-so-cc" class="headerlink" title="afl-llvm-pass.so.cc"></a>afl-llvm-pass.so.cc</h2><p>llvm开发者手册：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23599965/article/details/88538590">https://blog.csdn.net/qq_23599965/article/details/88538590</a></p>
<p>llvm API ：<a target="_blank" rel="noopener" href="https://llvm.org/doxygen/classllvm_1_1Instruction.html">https://llvm.org/doxygen/classllvm_1_1Instruction.html</a></p>
<h3 id="LLVM-前置知识"><a href="#LLVM-前置知识" class="headerlink" title="LLVM 前置知识"></a>LLVM 前置知识</h3><p>LLVM 主要为了解决编译时多种多样的前端和后端导致编译环境复杂、苛刻的问题，其核心为设计了一个称为 <code>LLVM IR</code> 的中间表示，并以库的形式提供一些列接口，以提供诸如操作 IR 、生成目标平台代码等等后端的功能。其整体架构如下所示：</p>
<p><img src="/photo/779730_GXSEXM24ZC32HRF.jpg" alt="img"></p>
<p> 不同的前端和后端使用统一的中间代码<code>LLVM InterMediate Representation(LLVM IR)</code>，其结果就是如果需要支持一门新的编程语言，只需要实现一个新的前端；如果需要支持一款新的硬件设备，只需要实现一个新的后端；优化阶段为通用阶段，针对统一的 LLVM IR ，与新的编程语言和硬件设备无关。GCC 的前后端耦合在一起，没有进行分离，所以GCC为了支持一门新的编程语言或一个新的硬件设备，需要重新开发前端到后端的完整过程。Clang 是 LLVM 项目的一个子项目，它是 LLVM 架构下的 C&#x2F;C++&#x2F;Objective-C 的编译器，是 LLVM 前端的一部分。相较于GCC，具备编译速度快、占用内存少、模块化设计、诊断信息可读性强、设计清晰简单等优点。最终从源码到机器码的流程如下（以 Clang 做编译器为例）：</p>
<p><img src="/photo/779730_WNCMH89CW5PFWMW.jpg" alt="20210906150020"></p>
<p> （LLVM Pass 是一些中间过程处理 IR 的可以用户自定义的内容，可以用来遍历、修改 IR 以达到插桩、优化、静态分析等目的。）代码首先由编译器前端clang处理后得到中间代码IR，然后经过各 LLVM Pass 进行优化和转换，最终交给编译器后端生成机器码。</p>
<h3 id="register-pass"><a href="#register-pass" class="headerlink" title="register pass"></a>register pass</h3><p>注册pass</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerAFLPass</span><span class="params">(<span class="type">const</span> PassManagerBuilder &amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                            legacy::PassManagerBase &amp;PM)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  PM.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">AFLCoverage</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterStandardPasses <span class="title">RegisterAFLPass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PassManagerBuilder::EP_ModuleOptimizerEarly, registerAFLPass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterStandardPasses <span class="title">RegisterAFLPass0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PassManagerBuilder::EP_EnabledOnOptLevel0, registerAFLPass)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="runOnModule"><a href="#runOnModule" class="headerlink" title="runOnModule"></a>runOnModule</h3><p>AFLCoverage类继承自ModulePass类，重写runOnModule方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">AFLCoverage</span> : <span class="keyword">public</span> ModulePass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">      <span class="built_in">AFLCoverage</span>() : <span class="built_in">ModulePass</span>(ID) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">runOnModule</span><span class="params">(Module &amp;M)</span> <span class="keyword">override</span></span>;</span><br><span class="line">      <span class="comment">// StringRef getPassName() const override &#123;</span></span><br><span class="line">      <span class="comment">//  return &quot;American Fuzzy Lop Instrumentation&quot;;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AFLCoverage::runOnModule</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  LLVMContext &amp;C = M.<span class="built_in">getContext</span>();<span class="comment">// 获取进程上下文</span></span><br><span class="line">  IntegerType *Int8Ty  = IntegerType::<span class="built_in">getInt8Ty</span>(C);</span><br><span class="line">  IntegerType *Int32Ty = IntegerType::<span class="built_in">getInt32Ty</span>(C);</span><br><span class="line">  <span class="comment">/* Show a banner */</span></span><br><span class="line">  <span class="type">char</span> be_quiet = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isatty</span>(<span class="number">2</span>) &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-llvm-pass &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Decide instrumentation ratio 插桩比例确定*/</span> </span><br><span class="line">  <span class="type">char</span>* inst_ratio_str = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> inst_ratio = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || !inst_ratio ||</span><br><span class="line">        inst_ratio &gt; <span class="number">100</span>)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 1 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get globals for the SHM region and the previous location. Note that</span></span><br><span class="line"><span class="comment">     __afl_prev_loc is thread-local. 获取__afl_area_ptr(共享内存地址) 和 __afl_prev_loc(上一个基础块的编号) 两个全局变量*/</span></span><br><span class="line">  GlobalVariable *AFLMapPtr =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">GlobalVariable</span>(M, PointerType::<span class="built_in">get</span>(Int8Ty, <span class="number">0</span>), <span class="literal">false</span>,</span><br><span class="line">                         GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_area_ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">  GlobalVariable *AFLPrevLoc = <span class="keyword">new</span> <span class="built_in">GlobalVariable</span>(</span><br><span class="line">      M, Int32Ty, <span class="literal">false</span>, GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_prev_loc&quot;</span>,</span><br><span class="line">      <span class="number">0</span>, GlobalVariable::GeneralDynamicTLSModel, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Instrument all the things!  插桩数*/</span></span><br><span class="line">  <span class="type">int</span> inst_blocks = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : M) <span class="comment">// 循环且采用了引用，改变F对M也进行修改。F是M中的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;BB : F) &#123; <span class="comment">// BB是F中的基本快 这里就是遍历基本快</span></span><br><span class="line">      <span class="comment">// BasicBlock是一种容器。每个容器都有相应的迭代器</span></span><br><span class="line">      BasicBlock::iterator IP = BB.<span class="built_in">getFirstInsertionPt</span>();</span><br><span class="line">      <span class="comment">// IRBuilder是一个方便的类，可以用来在一个 BasicBlock 的末尾或某个特定 Instruction 之前添加多个指令</span></span><br><span class="line">      IRBuilder&lt;&gt; <span class="built_in">IRB</span>(&amp;(*IP));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">AFL_R</span>(<span class="number">100</span>) &gt;= inst_ratio) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make up cur_loc 随机插桩id*/</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> cur_loc = <span class="built_in">AFL_R</span>(MAP_SIZE);</span><br><span class="line">      ConstantInt *CurLoc = ConstantInt::<span class="built_in">get</span>(Int32Ty, cur_loc);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Load prev_loc */</span></span><br><span class="line">      <span class="comment">// 通过插入load指令来获取前一个基本块的编号</span></span><br><span class="line">      LoadInst *PrevLoc = IRB.<span class="built_in">CreateLoad</span>(AFLPrevLoc);</span><br><span class="line">      PrevLoc-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">      Value *PrevLocCasted = IRB.<span class="built_in">CreateZExt</span>(PrevLoc, IRB.<span class="built_in">getInt32Ty</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Load SHM pointer */</span></span><br><span class="line">      <span class="comment">// 通过插入load指令来获取共享内存的地址，并通过CreateGEP函数来获取共享内存里指定index的地址，这个index通过cur_loc和		prev_loc取xor计算得到</span></span><br><span class="line">      LoadInst *MapPtr = IRB.<span class="built_in">CreateLoad</span>(AFLMapPtr);</span><br><span class="line">      MapPtr-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">      Value *MapPtrIdx =</span><br><span class="line">          IRB.<span class="built_in">CreateGEP</span>(MapPtr, IRB.<span class="built_in">CreateXor</span>(PrevLocCasted, CurLoc));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Update bitmap */</span></span><br><span class="line">      <span class="comment">// 通过插入load指令来读取对应index地址的值，并通过插入add指令来将其加一，然后通过创建store指令将新值写入，更新共享内			存。</span></span><br><span class="line">      LoadInst *Counter = IRB.<span class="built_in">CreateLoad</span>(MapPtrIdx);</span><br><span class="line">      Counter-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">      Value *Incr = IRB.<span class="built_in">CreateAdd</span>(Counter, ConstantInt::<span class="built_in">get</span>(Int8Ty, <span class="number">1</span>));</span><br><span class="line">      IRB.<span class="built_in">CreateStore</span>(Incr, MapPtrIdx)</span><br><span class="line">          -&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span></span><br><span class="line">      <span class="comment">// 将当前cur_loc的值右移一位，然后通过插入store指令，更新__afl_prev_loc的值</span></span><br><span class="line">      StoreInst *Store =</span><br><span class="line">          IRB.<span class="built_in">CreateStore</span>(ConstantInt::<span class="built_in">get</span>(Int32Ty, cur_loc &gt;&gt; <span class="number">1</span>), AFLPrevLoc);</span><br><span class="line">      Store-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">      inst_blocks++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* Say something nice. */</span></span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!inst_blocks) <span class="built_in">WARNF</span>(<span class="string">&quot;No instrumentation targets found.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">OKF</span>(<span class="string">&quot;Instrumented %u locations (%s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">             inst_blocks, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> :</span><br><span class="line">             ((<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || <span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) ?</span><br><span class="line">              <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>), inst_ratio);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">filename : llvm_test.c</span></span><br><span class="line"><span class="comment">obj : llvm_test.ll</span></span><br><span class="line"><span class="comment">Make :</span></span><br><span class="line"><span class="comment">    clang -emit-llvm -S llvm_test.c -o llvm_test.ll</span></span><br><span class="line"><span class="comment">    AFL_DONT_OPTIMIZE=1 afl-clang-fast -emit-llvm -S llvm_test.c -o llvm_test_fast.ll</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(<span class="number">0</span>, buf, <span class="number">8</span>) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hum?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Looks like a zero to me!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A non-zero value? How quaint!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="未插桩的IR"><a href="#未插桩的IR" class="headerlink" title="未插桩的IR"></a>未插桩的IR</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = &#x27;llvm_test.c&#x27;</span><br><span class="line">source_filename = &quot;llvm_test.c&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">@.str = private unnamed_addr constant [6 x i8] c&quot;Hum?\0A\00&quot;, align 1</span><br><span class="line">@.str.1 = private unnamed_addr constant [26 x i8] c&quot;Looks like a zero to me!\0A\00&quot;, align 1</span><br><span class="line">@.str.2 = private unnamed_addr constant [31 x i8] c&quot;A non-zero value? How quaint!\0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @main(i32 %0, i8** %1) #0 &#123;</span><br><span class="line">  %3 = alloca i32, align 4</span><br><span class="line">  %4 = alloca i32, align 4</span><br><span class="line">  %5 = alloca i8**, align 8</span><br><span class="line">  %6 = alloca [8 x i8], align 1</span><br><span class="line">  store i32 0, i32* %3, align 4</span><br><span class="line">  store i32 %0, i32* %4, align 4</span><br><span class="line">  store i8** %1, i8*** %5, align 8</span><br><span class="line">  %7 = getelementptr inbounds [8 x i8], [8 x i8]* %6, i64 0, i64 0</span><br><span class="line">  %8 = call i64 @read(i32 0, i8* %7, i64 8)</span><br><span class="line">  %9 = icmp slt i64 %8, 1</span><br><span class="line">  br i1 %9, label %10, label %12</span><br><span class="line"></span><br><span class="line">10:                                               ; preds = %2</span><br><span class="line">  %11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))</span><br><span class="line">  call void @exit(i32 1) #3</span><br><span class="line">  unreachable</span><br><span class="line"></span><br><span class="line">12:                                               ; preds = %2</span><br><span class="line">  %13 = getelementptr inbounds [8 x i8], [8 x i8]* %6, i64 0, i64 0</span><br><span class="line">  %14 = load i8, i8* %13, align 1</span><br><span class="line">  %15 = sext i8 %14 to i32</span><br><span class="line">  %16 = icmp eq i32 %15, 48</span><br><span class="line">  br i1 %16, label %17, label %19</span><br><span class="line"></span><br><span class="line">17:                                               ; preds = %12</span><br><span class="line">  %18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1, i64 0, i64 0))</span><br><span class="line">  br label %21</span><br><span class="line"></span><br><span class="line">19:                                               ; preds = %12</span><br><span class="line">  %20 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.2, i64 0, i64 0))</span><br><span class="line">  br label %21</span><br><span class="line"></span><br><span class="line">21:                                               ; preds = %19, %17</span><br><span class="line">  call void @exit(i32 0) #3</span><br><span class="line">  unreachable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare dso_local i64 @read(i32, i8*, i64) #1</span><br><span class="line"></span><br><span class="line">declare dso_local i32 @printf(i8*, ...) #1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noreturn nounwind</span><br><span class="line">declare dso_local void @exit(i32) #2</span><br><span class="line"></span><br><span class="line">attributes #0 = &#123; noinline nounwind optnone uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;frame-pointer&quot;=&quot;all&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #1 = &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;frame-pointer&quot;=&quot;all&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #2 = &#123; noreturn nounwind &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;frame-pointer&quot;=&quot;all&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #3 = &#123; noreturn nounwind &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0&#125;</span><br><span class="line">!llvm.ident = !&#123;!1&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 = !&#123;!&quot;clang version 10.0.0-4ubuntu1~18.04.2 &quot;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="插桩后的IR"><a href="#插桩后的IR" class="headerlink" title="插桩后的IR"></a>插桩后的IR</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = &#x27;llvm_test.c&#x27;</span><br><span class="line">source_filename = &quot;llvm_test.c&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">@.str = private unnamed_addr constant [6 x i8] c&quot;Hum?\0A\00&quot;, align 1</span><br><span class="line">@.str.1 = private unnamed_addr constant [26 x i8] c&quot;Looks like a zero to me!\0A\00&quot;, align 1</span><br><span class="line">@.str.2 = private unnamed_addr constant [31 x i8] c&quot;A non-zero value? How quaint!\0A\00&quot;, align 1</span><br><span class="line">@__afl_area_ptr = external global i8*</span><br><span class="line">@__afl_prev_loc = external thread_local global i32</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @main(i32 %0, i8** %1) #0 &#123;</span><br><span class="line">  %3 = load i32, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %4 = load i8*, i8** @__afl_area_ptr, !nosanitize !2</span><br><span class="line">  %5 = xor i32 %3, 9154</span><br><span class="line">  %6 = getelementptr i8, i8* %4, i32 %5</span><br><span class="line">  %7 = load i8, i8* %6, !nosanitize !2</span><br><span class="line">  %8 = add i8 %7, 1</span><br><span class="line">  store i8 %8, i8* %6, !nosanitize !2</span><br><span class="line">  store i32 4577, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %9 = alloca i32, align 4</span><br><span class="line">  %10 = alloca i32, align 4</span><br><span class="line">  %11 = alloca i8**, align 8</span><br><span class="line">  %12 = alloca [8 x i8], align 1</span><br><span class="line">  store i32 0, i32* %9, align 4</span><br><span class="line">  store i32 %0, i32* %10, align 4</span><br><span class="line">  store i8** %1, i8*** %11, align 8</span><br><span class="line">  %13 = getelementptr inbounds [8 x i8], [8 x i8]* %12, i64 0, i64 0</span><br><span class="line">  %14 = call i64 @read(i32 0, i8* %13, i64 8)</span><br><span class="line">  %15 = icmp slt i64 %14, 1</span><br><span class="line">  br i1 %15, label %16, label %24</span><br><span class="line"></span><br><span class="line">16:                                               ; preds = %2</span><br><span class="line">  %17 = load i32, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %18 = load i8*, i8** @__afl_area_ptr, !nosanitize !2</span><br><span class="line">  %19 = xor i32 %17, 21110</span><br><span class="line">  %20 = getelementptr i8, i8* %18, i32 %19</span><br><span class="line">  %21 = load i8, i8* %20, !nosanitize !2</span><br><span class="line">  %22 = add i8 %21, 1</span><br><span class="line">  store i8 %22, i8* %20, !nosanitize !2</span><br><span class="line">  store i32 10555, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))</span><br><span class="line">  call void @exit(i32 1) #3</span><br><span class="line">  unreachable</span><br><span class="line"></span><br><span class="line">24:                                               ; preds = %2</span><br><span class="line">  %25 = load i32, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %26 = load i8*, i8** @__afl_area_ptr, !nosanitize !2</span><br><span class="line">  %27 = xor i32 %25, 62847</span><br><span class="line">  %28 = getelementptr i8, i8* %26, i32 %27</span><br><span class="line">  %29 = load i8, i8* %28, !nosanitize !2</span><br><span class="line">  %30 = add i8 %29, 1</span><br><span class="line">  store i8 %30, i8* %28, !nosanitize !2</span><br><span class="line">  store i32 31423, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %31 = getelementptr inbounds [8 x i8], [8 x i8]* %12, i64 0, i64 0</span><br><span class="line">  %32 = load i8, i8* %31, align 1</span><br><span class="line">  %33 = sext i8 %32 to i32</span><br><span class="line">  %34 = icmp eq i32 %33, 48</span><br><span class="line">  br i1 %34, label %35, label %43</span><br><span class="line"></span><br><span class="line">35:                                               ; preds = %24</span><br><span class="line">  %36 = load i32, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %37 = load i8*, i8** @__afl_area_ptr, !nosanitize !2</span><br><span class="line">  %38 = xor i32 %36, 56885</span><br><span class="line">  %39 = getelementptr i8, i8* %37, i32 %38</span><br><span class="line">  %40 = load i8, i8* %39, !nosanitize !2</span><br><span class="line">  %41 = add i8 %40, 1</span><br><span class="line">  store i8 %41, i8* %39, !nosanitize !2</span><br><span class="line">  store i32 28442, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %42 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1, i64 0, i64 0))</span><br><span class="line">  br label %51</span><br><span class="line"></span><br><span class="line">43:                                               ; preds = %24</span><br><span class="line">  %44 = load i32, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %45 = load i8*, i8** @__afl_area_ptr, !nosanitize !2</span><br><span class="line">  %46 = xor i32 %44, 30262</span><br><span class="line">  %47 = getelementptr i8, i8* %45, i32 %46</span><br><span class="line">  %48 = load i8, i8* %47, !nosanitize !2</span><br><span class="line">  %49 = add i8 %48, 1</span><br><span class="line">  store i8 %49, i8* %47, !nosanitize !2</span><br><span class="line">  store i32 15131, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %50 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.2, i64 0, i64 0))</span><br><span class="line">  br label %51</span><br><span class="line"></span><br><span class="line">51:                                               ; preds = %43, %35</span><br><span class="line">  %52 = load i32, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  %53 = load i8*, i8** @__afl_area_ptr, !nosanitize !2</span><br><span class="line">  %54 = xor i32 %52, 61164</span><br><span class="line">  %55 = getelementptr i8, i8* %53, i32 %54</span><br><span class="line">  %56 = load i8, i8* %55, !nosanitize !2</span><br><span class="line">  %57 = add i8 %56, 1</span><br><span class="line">  store i8 %57, i8* %55, !nosanitize !2</span><br><span class="line">  store i32 30582, i32* @__afl_prev_loc, !nosanitize !2</span><br><span class="line">  call void @exit(i32 0) #3</span><br><span class="line">  unreachable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare dso_local i64 @read(i32, i8*, i64) #1</span><br><span class="line"></span><br><span class="line">declare dso_local i32 @printf(i8*, ...) #1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noreturn nounwind</span><br><span class="line">declare dso_local void @exit(i32) #2</span><br><span class="line"></span><br><span class="line">attributes #0 = &#123; noinline nounwind optnone uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;frame-pointer&quot;=&quot;all&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #1 = &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;frame-pointer&quot;=&quot;all&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #2 = &#123; noreturn nounwind &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;frame-pointer&quot;=&quot;all&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;</span><br><span class="line">attributes #3 = &#123; noreturn nounwind &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0&#125;</span><br><span class="line">!llvm.ident = !&#123;!1&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 = !&#123;!&quot;clang version 10.0.0-4ubuntu1~18.04.2 &quot;&#125;</span><br><span class="line">!2 = !&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="afl-llvm-rt-o-c"><a href="#afl-llvm-rt-o-c" class="headerlink" title="afl-llvm-rt.o.c"></a>afl-llvm-rt.o.c</h2><p>AFL的LLVM_Mode中存在着三个特殊的功能。这三个功能的源码位于afl-llvm-rt.o.c中。</p>
<ul>
<li>deferred instrumentation 延迟仪器 </li>
<li>persistent mode 持续模式</li>
<li>trace-pc-guard mode 跟踪pc监管模式</li>
</ul>
<p>关键变量和环境变量：</p>
<ul>
<li><code>DEFER_ENV_VAR</code> 延迟仪器的环境变量</li>
<li><code>is_persistent / PERSIST_ENV_VAR</code> 持续模式的标准位和环境变量</li>
<li><code>__AFL_INIT() / __AFL_LOOP(_A) </code></li>
</ul>
<h3 id="deferred-instrumentation"><a href="#deferred-instrumentation" class="headerlink" title="deferred instrumentation"></a>deferred instrumentation</h3><p>AFL会尝试通过仅执行一次目标二进制文件来优化性能。它会暂停控制流，然后<strong>复制</strong>该“主”进程以持续提供fuzzer的目标，<strong>即每一次fuzz都需要fork一个子进程</strong>。<strong>该功能在某些情况下可以减少操作系统、链接与libc内部执行程序的成本</strong>。选好位置后，将下述代码添加到该位置上，之后使用afl-clang-fast重新编译代码即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL</span></span><br><span class="line">  __AFL_INIT();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __AFL_HAVE_MANUAL_CONTROL 和 __AFL_INIT() 宏都是在afl-clang-fast.c 被添加为命令行参数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-D__AFL_HAVE_MANUAL_CONTROL=1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-D__AFL_INIT()=do &#123;</span></span><br><span class="line"><span class="comment">static volatile char *_A __attribute__((used));  </span></span><br><span class="line"><span class="comment">_A = (char*)\&quot;##SIG_AFL_DEFER_FORKSRV##\&quot;;</span></span><br><span class="line"><span class="comment">__attribute__((visibility(\&quot;default\&quot;))) void _I(void) __asm__(\&quot;__afl_manual_init\&quot;); </span></span><br><span class="line"><span class="comment">_I();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>__AFL_INIT()</code>内部调用<code>__afl_manual_init</code>函数。该函数的源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __afl_manual_init(<span class="type">void</span>) &#123;</span><br><span class="line">  <span class="type">static</span> u8 init_done;</span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line">    __afl_map_shm(); <span class="comment">// 获取环境变量SHM_ENV_VAR 并且初始化 __afl_area_ptr </span></span><br><span class="line">    __afl_start_forkserver(); <span class="comment">// 进入forkserver服务</span></span><br><span class="line">    init_done = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 共享内存</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __afl_map_shm(<span class="type">void</span>) &#123;</span><br><span class="line">  u8 *id_str = getenv(SHM_ENV_VAR);</span><br><span class="line">  <span class="keyword">if</span> (id_str) &#123;</span><br><span class="line">    u32 shm_id = atoi(id_str);</span><br><span class="line">    __afl_area_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">// 申请资源了</span></span><br><span class="line">    <span class="keyword">if</span> (__afl_area_ptr == (<span class="type">void</span> *)<span class="number">-1</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fork server logic. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __afl_start_forkserver(<span class="type">void</span>) &#123;</span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">4</span>];</span><br><span class="line">  s32 child_pid;</span><br><span class="line">  u8  child_stopped = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 给afl-fuzz发送信息</span></span><br><span class="line">  <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    u32 was_killed;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line">    <span class="comment">// 等待afl-fuzz的信息</span></span><br><span class="line">    <span class="keyword">if</span> (read(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 子进程停止且afl-fuzz发送了SIGKILL则注销旧进程</span></span><br><span class="line">    <span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123;</span><br><span class="line">       <span class="comment">// deferred instrumentation mode</span></span><br><span class="line">       <span class="comment">// 设置了child_stopped = 1 才可能进入这里</span></span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!child_stopped) &#123;</span><br><span class="line">      child_pid = fork();</span><br><span class="line">      <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line">        <span class="comment">// 子进程 关闭描述符然后return接着正常执行</span></span><br><span class="line">        close(FORKSRV_FD);</span><br><span class="line">        close(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 处于persistent mode模式</span></span><br><span class="line">	 <span class="comment">// 向子进程发送SIGCONT 即继续的信号</span></span><br><span class="line">     <span class="comment">// 设置了child_stopped = 1 才可能进入这里</span></span><br><span class="line">      kill(child_pid, SIGCONT);</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>)<span class="comment">// 接受子进程的状态</span></span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (WIFSTOPPED(status)) child_stopped = <span class="number">1</span>; <span class="comment">// 处于persistent mode 设置了child_stopped = 1</span></span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line">  &#125;<span class="comment">// while end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="persistent-mode"><a href="#persistent-mode" class="headerlink" title="persistent mode"></a>persistent mode</h3><p>在这个模式下可以持续对一个区域进行测试，而<strong>不需要</strong>每一次fuzz都需要fork一个子进程，可以在一个子进程中进行循环测试n次。</p>
<p>使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">  <span class="comment">// 要执行的区域</span></span><br><span class="line">  <span class="comment">/* Read input data. */</span></span><br><span class="line">  <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">  <span class="comment">/* Reset state. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	__AFL_LOOP(_A) 在afl-clang-fast.c中被添加为命令行参数</span></span><br><span class="line"><span class="comment">-D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)\&quot;##SIG_AFL_PERSISTENT##\&quot;; __attribute__((visibility(\&quot;default\&quot;))) int _L(unsigned int) __asm__(\&quot;__afl_persistent_loop\&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Proper initialization routine. */</span></span><br><span class="line"><span class="comment">// 在main之前被执行自动初始化</span></span><br><span class="line">__attribute__((constructor(CONST_PRIO))) <span class="type">void</span> __afl_auto_init(<span class="type">void</span>) &#123;</span><br><span class="line">  is_persistent = !!getenv(PERSIST_ENV_VAR);</span><br><span class="line">  <span class="comment">// 如果设置了deferred instrumentation 就直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(DEFER_ENV_VAR)) <span class="keyword">return</span>;</span><br><span class="line">  __afl_manual_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 __AFL_LOOP(_A) 中被调用</span></span><br><span class="line"><span class="type">int</span> __afl_persistent_loop(<span class="type">unsigned</span> <span class="type">int</span> max_cnt) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8  first_pass = <span class="number">1</span>;</span><br><span class="line">  <span class="type">static</span> u32 cycle_cnt;</span><br><span class="line">  <span class="keyword">if</span> (first_pass) &#123;</span><br><span class="line">    <span class="comment">// 第一次循环</span></span><br><span class="line">    <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">      <span class="comment">// persistent mode</span></span><br><span class="line">      <span class="built_in">memset</span>(__afl_area_ptr, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cycle_cnt  = max_cnt;</span><br><span class="line">    first_pass = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// persistent mode</span></span><br><span class="line">  <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (--cycle_cnt) &#123; <span class="comment">// 继续外循环直到cycle_cnt = 0</span></span><br><span class="line">      raise(SIGSTOP); <span class="comment">// 发送SIGSTOP信号通知父进程的__afl_start_forkserver函数</span></span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化开始下一次循环</span></span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 从这里出去就是继续循环</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//  __AFL_LOOP(_A)结束</span></span><br><span class="line">      __afl_area_ptr = __afl_area_initial;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 从这里出去就是结束循环</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="trace-pc-guard-mode"><a href="#trace-pc-guard-mode" class="headerlink" title="trace-pc-guard mode"></a>trace-pc-guard mode</h3><p>要使用这个功能，需要先通过<code>AFL_TRACE_PC=1</code>来定义-DUSE_TRACE_PC宏，从而在执行afl-clang-fast的时候传入<code>-fsanitize-coverage=trace-pc-guard</code>参数，来开启这个功能，和之前我们的插桩不同，开启了这个功能之后，我们不再是仅仅只对每个基本块插桩，而是对每条edge都进行了插桩。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> AFL_TRACE_PC</span><br><span class="line">  CFLAGS    += -DUSE_TRACE_PC=1</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span>* guard) &#123;</span><br><span class="line">  __afl_area_ptr[*guard]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Init callback. Populates instrumentation IDs. Note that we&#x27;re using</span></span><br><span class="line"><span class="comment">   ID of 0 as a special value to indicate non-instrumented bits. That may</span></span><br><span class="line"><span class="comment">   still touch the bitmap, but in a fairly harmless way. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span>* start, <span class="type">uint32_t</span>* stop) &#123;</span><br><span class="line"></span><br><span class="line">  u32 inst_ratio = <span class="number">100</span>;</span><br><span class="line">  u8* x;</span><br><span class="line">  <span class="comment">// 是否已经初始化</span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 对inst_ratio 进行合法检查</span></span><br><span class="line">  x = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (x) inst_ratio = atoi(x);</span><br><span class="line">  <span class="keyword">if</span> (!inst_ratio || inst_ratio &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[-] ERROR: Invalid AFL_INST_RATIO (must be 1-100).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Make sure that the first element in the range is always set - we use that</span></span><br><span class="line"><span class="comment">     to avoid duplicate calls (which can happen as an artifact of the underlying</span></span><br><span class="line"><span class="comment">     implementation in LLVM). */</span></span><br><span class="line">  <span class="comment">// 设置第一个位置的值</span></span><br><span class="line">  *(start++) = R(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 随机生成后面的值</span></span><br><span class="line">  <span class="keyword">while</span> (start &lt; stop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (R(<span class="number">100</span>) &lt; inst_ratio) *start = R(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> *start = <span class="number">0</span>; <span class="comment">// 把0当成一个特殊的值，其代表对这个edge不进行插桩</span></span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h2><p>AFL中最重要的部分便是fuzzer的实现部分—<code>afl_fuzz.c</code> ，其主要作用是通过不断变异测试用例来影响程序的执行路径。</p>
<h3 id="main源码"><a href="#main源码" class="headerlink" title="main源码"></a>main源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  s32 opt;</span><br><span class="line">  u64 prev_queued = <span class="number">0</span>;</span><br><span class="line">  u32 sync_interval_cnt = <span class="number">0</span>, seek_to;</span><br><span class="line">  u8  *extras_dir = <span class="number">0</span>;</span><br><span class="line">  u8  mem_limit_given = <span class="number">0</span>;</span><br><span class="line">  u8  exit_1 = !!getenv(<span class="string">&quot;AFL_BENCH_JUST_ONE&quot;</span>);</span><br><span class="line">  <span class="type">char</span>** use_argv;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line"></span><br><span class="line">  SAYF(cCYA <span class="string">&quot;afl-fuzz &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  doc_path = access(DOC_PATH, F_OK) ? <span class="string">&quot;docs&quot;</span> : DOC_PATH;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);</span><br><span class="line">  srandom(tv.tv_sec ^ tv.tv_usec ^ getpid());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_dir) FATAL(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">        in_dir = optarg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* output dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_dir) FATAL(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">        out_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123; <span class="comment">/* master sync ID */</span></span><br><span class="line"></span><br><span class="line">          u8* c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (sync_id) FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">          sync_id = ck_strdup(optarg);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>(sync_id, <span class="string">&#x27;:&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            *c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">                !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">                master_max &gt; <span class="number">1000000</span>) FATAL(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          force_deterministic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sync_id) FATAL(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = ck_strdup(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* target file */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_file) FATAL(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">        out_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* dictionary */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extras_dir) FATAL(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">        extras_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123; <span class="comment">/* timeout */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (timeout_given) FATAL(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>) FATAL(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>) timeout_given = <span class="number">2</span>; <span class="keyword">else</span> timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: &#123; <span class="comment">/* mem limit */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit_given) FATAL(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">          mem_limit_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            mem_limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:  FATAL(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>) FATAL(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">            FATAL(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123; <span class="comment">/* bind CPU core */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cpu_to_bind_given) FATAL(<span class="string">&quot;Multiple -b options not supported&quot;</span>);</span><br><span class="line">          cpu_to_bind_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u&quot;</span>, &amp;cpu_to_bind) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) FATAL(<span class="string">&quot;Bad syntax used for -b&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* skip deterministic */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_deterministic) FATAL(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">        skip_deterministic = <span class="number">1</span>;</span><br><span class="line">        use_splicing = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* load bitmap */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This is a secret undocumented option! It is useful if you find</span></span><br><span class="line"><span class="comment">           an interesting test case during a normal fuzzing process, and want</span></span><br><span class="line"><span class="comment">           to mutate it without rediscovering any of the test cases already</span></span><br><span class="line"><span class="comment">           found during an earlier run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           To use this mode, you need to point -B to the fuzz_bitmap produced</span></span><br><span class="line"><span class="comment">           by an earlier run for the exact same binary... and that&#x27;s it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           I only used this once or twice to get variants of a particular</span></span><br><span class="line"><span class="comment">           file, so I&#x27;m not making this an official setting. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_bitmap) FATAL(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in_bitmap = optarg;</span><br><span class="line">        read_bitmap(in_bitmap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* crash mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">        crash_mode = FAULT_CRASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* dumb mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dumb_mode) FATAL(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>)) dumb_mode = <span class="number">2</span>; <span class="keyword">else</span> dumb_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* banner */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_banner) FATAL(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">        use_banner = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_mode) FATAL(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">        qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="comment">/* Show version number */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Version number has been printed already, just quit. */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  setup_signal_handlers();</span><br><span class="line">  check_asan_opts();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sync_id) fix_up_sync(); <span class="comment">// sync_id 根据命令行参数指定 -M 或者 -S 进行设置</span></span><br><span class="line">  <span class="comment">// 两个文件目录不相同则退出</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">    FATAL(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line">  <span class="comment">// dumb_mode 由-n设置 如果设置了AFL_DUMB_FORKSRV环境变量 dumb_mode = 2 否则 dumb_mode = 1</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (qemu_mode)  FATAL(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>)) &#123;</span><br><span class="line">    hang_tmout = atoi(getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!hang_tmout) FATAL(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">    FATAL(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">    setenv(<span class="string">&quot;LD_PRELOAD&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    setenv(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">    FATAL(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br><span class="line"></span><br><span class="line">  save_cmdline(argc, argv);  <span class="comment">// 保存原始的命令行参数 存放在orig_cmdline区域</span></span><br><span class="line"></span><br><span class="line">  fix_up_banner(argv[optind]); <span class="comment">// 设置一个字符串 修剪并且创建一个运行横幅</span></span><br><span class="line"></span><br><span class="line">  check_if_tty(); <span class="comment">// 检查是否处于终端</span></span><br><span class="line"></span><br><span class="line">  get_core_count(); <span class="comment">// 获取core数量和可执行进程的数量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  bind_to_free_cpu();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br><span class="line"></span><br><span class="line">  check_crash_handling(); </span><br><span class="line">  check_cpu_governor();</span><br><span class="line"></span><br><span class="line">  setup_post();</span><br><span class="line">  setup_shm();</span><br><span class="line">  init_count_class16();</span><br><span class="line"></span><br><span class="line">  setup_dirs_fds();</span><br><span class="line">  read_testcases();</span><br><span class="line">  load_auto();</span><br><span class="line"></span><br><span class="line">  pivot_inputs();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extras_dir) load_extras(extras_dir);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) find_timeout();</span><br><span class="line"></span><br><span class="line">  detect_file_args(argv + optind + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!out_file) setup_stdio_file();</span><br><span class="line"></span><br><span class="line">  check_binary(argv[optind]);</span><br><span class="line"></span><br><span class="line">  start_time = get_cur_time();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)</span><br><span class="line">    use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    use_argv = argv + optind;</span><br><span class="line"></span><br><span class="line">  perform_dry_run(use_argv);</span><br><span class="line"></span><br><span class="line">  cull_queue();</span><br><span class="line"></span><br><span class="line">  show_init_stats();</span><br><span class="line"></span><br><span class="line">  seek_to = find_start_position();</span><br><span class="line"></span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  save_auto();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Woop woop woop */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">    sleep(<span class="number">4</span>);</span><br><span class="line">    start_time += <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">    cull_queue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line"></span><br><span class="line">      queue_cycle++;</span><br><span class="line">      current_entry     = <span class="number">0</span>;</span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">      queue_cur         = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      show_stats();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">        ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">         recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skipped_fuzz = fuzz_one(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">    current_entry++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur) show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we stopped programmatically, we kill the forkserver and the current runner. </span></span><br><span class="line"><span class="comment">     If we stopped manually, this is done by the signal handler. */</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) kill(child_pid, SIGKILL);</span><br><span class="line">      <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) kill(forksrv_pid, SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Now that we&#x27;ve killed the forkserver, we wait for it to be able to get rusage stats. */</span></span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">&quot;error waitpid\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_bitmap();</span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  save_auto();</span><br><span class="line"></span><br><span class="line">stop_fuzzing:</span><br><span class="line">  SAYF(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">       stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Running for more than 30 minutes but still doing first cycle? */</span></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; get_cur_time() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>, doc_path);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(plot_file);</span><br><span class="line">  destroy_queue();</span><br><span class="line">  destroy_extras();</span><br><span class="line">  ck_free(target_path);</span><br><span class="line">  ck_free(sync_id);</span><br><span class="line">  alloc_report();</span><br><span class="line">  OKF(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="main核心过程"><a href="#main核心过程" class="headerlink" title="main核心过程"></a>main核心过程</h3><p>运行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</span><br></pre></td></tr></table></figure>

<p>记录核心过程：</p>
<ol>
<li><pre><code class="c">// 对命令行参数进行解析
while ((opt = getopt(argc, argv, &quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;)) &gt; 0)
    switch(opt)&#123;...&#125;

out_file -f 设置 out_file = optarg
sync_id 根据命令行参数指定 -M 或者 -S 进行设置 sync_id 其实就是Fuzzer ID
dumb_mode 由-n设置 如果设置了AFL_DUMB_FORKSRV环境变量 dumb_mode = 2 否则 dumb_mode = 1
skip_deterministic -d 时设置 skip_deterministic = 1
force_deterministic -M 设置 force_deterministic = 1
cpu_to_bind_given -b 设置 cpu_to_bind_given = 1
in_bitmap -B 设置 in_bitmap = optarg
in_place_resume 当-i且输入文件夹为&#39;-&#39;时设置    in_place_resume = 1;
extras_dir -x 设置 extras_dir = optarg
timeout_given -t 设置 timeout_given = 2 或者 timeout_given = 1
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">2. `setup_signal_handlers()` 对一些信号设置处理函数</span><br><span class="line"></span><br><span class="line">3. `check_asan_opts()` 读取环境变量 `ASAN_OPTIONS` 和 `MSAN_OPTIONS`，做一些必要性检查</span><br><span class="line"></span><br><span class="line">4. `if (sync_id) fix_up_sync();`  主要时对opt一些选项的互斥检查，如果通过-M或者-S指定了sync_id，则更新out_dir和sync_dir的值</span><br><span class="line"></span><br><span class="line">   - 设置sync_dir的值为out_dir</span><br><span class="line">   - 设置out_dir的值为`out_dir/sync_id`</span><br><span class="line"></span><br><span class="line">5. `save_cmdline()` 保存原始的命令行参数 存放在`orig_cmdline` 全局指针变量上</span><br><span class="line"></span><br><span class="line">6. `fix_up_banner()` 修剪并且创建一个运行横幅</span><br><span class="line"></span><br><span class="line">7. `check_if_tty()` 检查是否在tty终端上面运行。</span><br><span class="line"></span><br><span class="line">   - 读取环境变量`AFL_NO_UI`的值，如果为真，则设置`not_on_tty = 1`，并返回</span><br><span class="line">   - `ioctl(1, TIOCGWINSZ, &amp;ws)`通过ioctl来读取window size，如果报错为ENOTTY，则代表当前不在一个tty终端运行，设置`not_on_tty = 1`</span><br><span class="line"></span><br><span class="line">8. `get_core_count()` 计算逻辑CPU核的数量。</span><br><span class="line"></span><br><span class="line">   - `cpu_core_count = sysconf(_SC_NPROCESSORS_ONLN)` 获取当前可获得的处理器个数</span><br><span class="line"></span><br><span class="line">9. `bind_to_free_cpu()` 将当前进程绑定到一个空闲的CPU上</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   cpu_set_t c;</span><br><span class="line">   // 一个CPU的亲合力掩码用一个cpu_set_t结构体来表示一个CPU集合</span><br><span class="line">   CPU_ZERO(&amp;c); // 清空一个集合</span><br><span class="line">   CPU_SET(i, &amp;c); // 将一个给定的CPU号i加到集合中</span><br><span class="line">   sched_setaffinity(0, sizeof(c), &amp;c)</span><br><span class="line">   /*</span><br><span class="line">   	sched_setaffinity(pid_t pid, unsigned int cpusetsize, cpu_set_t *mask) </span><br><span class="line">   	如果pid的值为0,则表示指定的是当前进程</span><br><span class="line">   	使当前进程运行在mask所设定的那些CPU上.第二个参数cpusetsize是mask所指定的数的长度</span><br><span class="line">   */</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p><code>check_crash_handling()</code> 检查核心转储文件的name</p>
</li>
<li><p><code>check_cpu_governor()</code> 检查CPU的统治，具体不清楚， 在WSL2上的话是直接返回了。</p>
</li>
<li><p><code>setup_post()</code> 如果设置了环境变量<code>AFL_POST_LIBRARY</code> 就加载后处理器</p>
</li>
<li><p><code>setup_shm()</code> </p>
<ul>
<li>如果<code>in_bitmap</code>未设置，则对 <code>virgin_bits/virgin_tmout/virgin_crash</code> 进行初始化</li>
<li>调用shmget分配一块共享内存返回资源id存放在<code>shm_id</code>中</li>
<li>设置在进程退出的时候执行 <code>remove_shm</code>函数</li>
<li>如果不是哑巴模式则设置一个环境变量<code>SHM_ENV_VAR</code>的值为共享内存的资源id，即<code>shm_id</code></li>
<li>设置<code>trace_bits</code>为分配出来的共享内存地址</li>
</ul>
</li>
<li><p><code>init_count_class16()</code></p>
</li>
<li><p><code>setup_dirs_fds()</code> 创建输出文件目录</p>
</li>
<li><p><code>read_testcase()</code> 从输入文件夹中读取所有文件，然后将它们排队进行测试</p>
<ul>
<li><code>add_to_queue(u8* fname, u32 len, u8 passed_det)</code> 添加新的测试用例到队列中</li>
</ul>
</li>
<li><p><code>load_auto()</code> 自动加载生成的额外测试用例</p>
<ul>
<li><code>maybe_add_auto(tmp, len)</code></li>
</ul>
</li>
<li><p><code>pivot_inputs()</code>  逻辑上说这个函数就是为inputdir里的testcase，在output dir里创建hard link，或者直接将内容复制到output dir中</p>
</li>
<li><p><code>if (extras_dir) load_extras(extras_dir)</code> 如果定义了extras_dir，则从extras_dir读取extras到extras数组里，并按size排序。</p>
</li>
<li><p><code>if (!timeout_given) find_timeout()</code> 如果<code>timeout_given</code>没有被设置，则进入<code>find_timeout</code></p>
</li>
<li><p><code>detect_file_args(argv + optind + 1)</code> 这个函数其实就是识别参数里面有没有<code>@@</code>，如果有就替换为<code>out_dir/.cur_input</code>，如果没有就返回</p>
</li>
<li><p><code>if (!out_file) setup_stdio_file()</code> 如果未使用-f设置out_file则执行<code>setup_stdio_file()</code> 删除原本的<code>out_dir/.cur_input</code>，创建一个新的<code>out_dir/.cur_input</code>，保存其文件描述符在<code>out_fd</code>中</p>
</li>
<li><p><code>check_binary(argv[optind])</code> 检查指定路径要执行的程序是否存在，是否为shell脚本，同时检查elf文件头是否合法及程序是否被插桩</p>
</li>
<li><p><code>perform_dry_run(char** argv)</code> 对所有测试用例进行试运行，以确认应用程序正在正常工作预期。这只对初始输入执行，并且只执行一次</p>
<ul>
<li><code>calibrate_case(argv, q, use_mem, 0, 1)</code>  参数对应为(要测试的二进制文件，队列元素，测试字符串数据，0，1)<ul>
<li><code>init_forkserver(argv)</code> </li>
<li><code>has_new_bits(u8 *virgin_map)</code></li>
<li><code>run_target(argv, use_tmout)</code></li>
<li><code>update_bitmap_score(struct queue_entry* q)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>cull_queue(void)</code></p>
</li>
<li><p>进入主循环</p>
<ul>
<li>首先精简队列<code>cull_queue</code></li>
<li>然后如果<code>queue_cur</code>为空，代表所有queue都被执行完一轮<ul>
<li>设置queue_cycle计数器加一，即代表所有queue被完整执行了多少轮。</li>
<li>设置current_entry为0，cur_skipped_paths为0，和queue_cur为queue首元素，开始新一轮fuzz。</li>
<li>如果是resume fuzz情况，则先检查seek_to是否为空，如果不为空，就从seek_to指定的queue项开始执行。</li>
<li>刷新展示界面<code>show_stats</code></li>
<li>如果在一轮执行之后的queue里的case数，和执行之前一样，代表在完整的一轮执行里都没有发现任何一个新的case<ul>
<li>如果<code>use_splicing</code>为1，就设置<code>cycles_wo_finds</code>计数器加1</li>
<li>否则，设置<code>use_splicing</code>为1，代表我们接下来要通过splice重组queue里的case。</li>
</ul>
</li>
<li><code>if (sync_id &amp;&amp; queue_cycle == 1 &amp;&amp; getenv(&quot;AFL_IMPORT_FIRST&quot;)) sync_fuzzers(use_argv);</code></li>
</ul>
</li>
<li>执行 <code>skipped_fuzz = fuzz_one(use_argv)</code> 来对queue_cur进行一次测试<ul>
<li>注意fuzz_one并不一定真的执行当前queue_cur，它是有一定策略的，如果不执行，就直接返回1，否则返回0</li>
</ul>
</li>
<li>如果skipped_fuzz为0，且存在sync_id<ul>
<li>sync_interval_cnt计数器加一，如果其结果是<code>SYNC_INTERVAL</code>(默认是5)的倍数，就进行一次<code>sync_fuzzers(use_argv)</code></li>
</ul>
</li>
<li><code>queue_cur = queue_cur-&gt;next;current_entry++;</code>，开始测试下一个queue</li>
</ul>
</li>
</ol>
<h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><h4 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h4><p>对一些信号设置处理函数</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>处理函数</th>
</tr>
</thead>
<tbody><tr>
<td>SIGHUP、SIGINT、SIGTERM</td>
<td>handle_stop_sig</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>handle_timeout</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>handle_resize</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>handle_skipreq</td>
</tr>
<tr>
<td>SIGTSTP、SIGPIPE</td>
<td>SIG_IGN 忽略</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_stop_sig</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  stop_soon = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) kill(child_pid, SIGKILL);</span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) kill(forksrv_pid, SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_skipreq</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  skip_requested = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_resize</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  clear_screen = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_timeout</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    kill(child_pid, SIGKILL);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">-1</span> &amp;&amp; forksrv_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    kill(forksrv_pid, SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Configure shared memory and virgin_bits. This is called at startup. */</span></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_shm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8* shm_str;</span><br><span class="line">  <span class="comment">// in_bitmap -B 设置 in_bitmap = optarg</span></span><br><span class="line">  <span class="comment">// 对 virgin_bits virgin_tmout virgin_crash 进行初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="comment">// 分配一块共享内存返回资源描述符</span></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line">  <span class="comment">// 设置在进程退出的时候执行 remove_shm函数</span></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不是哑巴模式则 设置一个环境变量SHM_ENV_VAR为共享内存的资源id</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line">  ck_free(shm_str);</span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// trace_bits为共享内存</span></span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="type">void</span> *)<span class="number">-1</span>) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare output directories and fds. */</span></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_dirs_fds</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u8* tmp;</span><br><span class="line">  s32 fd;</span><br><span class="line">  ACTF(<span class="string">&quot;Setting up output directories...&quot;</span>);</span><br><span class="line">  <span class="comment">// 是否设置sync_id</span></span><br><span class="line">  <span class="keyword">if</span> (sync_id &amp;&amp; mkdir(sync_dir, <span class="number">0700</span>) &amp;&amp; errno != EEXIST)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, sync_dir);</span><br><span class="line">  <span class="comment">// 创建 out_dir 文件夹</span></span><br><span class="line">  <span class="keyword">if</span> (mkdir(out_dir, <span class="number">0700</span>)) &#123;</span><br><span class="line">	<span class="comment">// 文件夹已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (errno != EEXIST) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, out_dir);</span><br><span class="line">	<span class="comment">// 检查文件夹中的相应文件是否删除旧的fuzz记录</span></span><br><span class="line">    maybe_delete_out_dir(); <span class="comment">// 可能会删除out_dir</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	in_place_resume 当-i且输入文件夹为&#x27;-&#x27;时设置 in_place_resume = 1;</span></span><br><span class="line"><span class="comment">	因为输入文件夹的信息可以在对应的输出文件夹中找到，所以可进行原地修复</span></span><br><span class="line"><span class="comment">	但是现在 out_dir 文件夹一开始是不存在的，现在创建成功了。</span></span><br><span class="line"><span class="comment">	这里如果设置了in_place_resume意味这无法通过旧的输出文件夹找到输入的信息。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="comment">// 创建文件夹成功</span></span><br><span class="line">    <span class="keyword">if</span> (in_place_resume)</span><br><span class="line">      FATAL(<span class="string">&quot;Resume attempted but old output directory not found&quot;</span>);</span><br><span class="line"></span><br><span class="line">    out_dir_fd = open(out_dir, O_RDONLY);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __sun</span></span><br><span class="line">    <span class="comment">// 对文件夹上锁</span></span><br><span class="line">    <span class="keyword">if</span> (out_dir_fd &lt; <span class="number">0</span> || flock(out_dir_fd, LOCK_EX | LOCK_NB))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to flock() output directory.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__sun */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Queue directory for any starting &amp; discovered paths. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Top-level directory for queue metadata used for session</span></span><br><span class="line"><span class="comment">     resume and related tasks. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Directory for flagging queue entries that went through</span></span><br><span class="line"><span class="comment">     deterministic fuzzing in the past. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/deterministic_done/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Directory with the auto-selected dictionary entries. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/auto_extras/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The set of paths currently deemed redundant. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/redundant_edges/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The set of paths showing variable behavior. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/variable_behavior/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sync directory for keeping track of cooperating fuzzers. */</span></span><br><span class="line">  <span class="comment">// 如果存在sync_id</span></span><br><span class="line">  <span class="keyword">if</span> (sync_id) &#123;</span><br><span class="line"></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/.synced/&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>) &amp;&amp; (!in_place_resume || errno != EEXIST))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">    ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All recorded crashes. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/crashes&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All recorded hangs. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/hangs&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generally useful file descriptors. */</span></span><br><span class="line"></span><br><span class="line">  dev_null_fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_null_fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open /dev/null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  dev_urandom_fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (dev_urandom_fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open /dev/urandom&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Gnuplot output file. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/plot_data&quot;</span>, out_dir);</span><br><span class="line">  fd = open(tmp, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  plot_file = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!plot_file) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(plot_file, <span class="string">&quot;# unix_time, cycles_done, cur_path, paths_total, &quot;</span></span><br><span class="line">                     <span class="string">&quot;pending_total, pending_favs, map_size, unique_crashes, &quot;</span></span><br><span class="line">                     <span class="string">&quot;unique_hangs, max_depth, execs_per_sec\n&quot;</span>);</span><br><span class="line">                     <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_testcases</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">nl</span>;</span></span><br><span class="line">  s32 nl_cnt;</span><br><span class="line">  u32 i;</span><br><span class="line">  u8* fn;</span><br><span class="line">  <span class="comment">/* Auto-detect non-in-place resumption attempts. */</span></span><br><span class="line">  <span class="comment">// 自动检查输入文件夹中的内容判断是否可以恢复旧的输入数据进行</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, in_dir);</span><br><span class="line">  <span class="keyword">if</span> (!access(fn, F_OK)) in_dir = fn; <span class="keyword">else</span> ck_free(fn);</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Scanning &#x27;%s&#x27;...&quot;</span>, in_dir);</span><br><span class="line">  <span class="comment">/* We use scandir() + alphasort() rather than readdir() because otherwise,</span></span><br><span class="line"><span class="comment">     the ordering  of test cases would vary somewhat randomly and would be</span></span><br><span class="line"><span class="comment">     difficult to control. */</span></span><br><span class="line">  <span class="comment">// nl_cnt 文件夹内的节点数量 nl为节点名字</span></span><br><span class="line">  nl_cnt = scandir(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line">  <span class="keyword">if</span> (nl_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT || errno == ENOTDIR)</span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;The input directory does not seem to be valid - try again. The fuzzer needs\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    one or more test case to start with - ideally, a small file under 1 kB\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    or so. The cases must be stored as regular files directly in the input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置了AFL_SHUFFLE_QUEUE环境变量则shuffle_queue = 1</span></span><br><span class="line">  <span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    ACTF(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">    shuffle_ptrs((<span class="type">void</span>**)nl, nl_cnt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    u8* fn = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    u8* dfn = alloc_printf(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    u8  passed_det = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (lstat(fn, &amp;st) || access(fn, R_OK))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.testcases&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      ck_free(fn);</span><br><span class="line">      ck_free(dfn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到testcase文件的信息</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">      FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">            DMS(st.st_size), DMS(MAX_FILE));</span><br><span class="line">    <span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">       is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">       fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">       and probably very time-consuming. */</span></span><br><span class="line">    <span class="comment">// dfn指向的文件是否可以访问</span></span><br><span class="line">    <span class="keyword">if</span> (!access(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">    ck_free(dfn);</span><br><span class="line">    add_to_queue(fn, st.st_size, passed_det); </span><br><span class="line"></span><br><span class="line">  &#125;<span class="comment">// end for</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(nl); <span class="comment">/* not tracked */</span></span><br><span class="line">  <span class="keyword">if</span> (!queued_paths) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Looks like there are no valid test cases in the input directory! The fuzzer\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    needs one or more test case to start with - ideally, a small file under\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    1 kB or so. The cases must be stored as regular files directly in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    input directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;No usable test cases in &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  last_path_time = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// queued_at_start 初始时输入测试用例的数量</span></span><br><span class="line">  <span class="comment">// queued_paths 队列中测试用例的数量</span></span><br><span class="line">  queued_at_start = queued_paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="add-to-queue"><a href="#add-to-queue" class="headerlink" title="add_to_queue"></a>add_to_queue</h4><p>queue_entry是一个链表数据结构，先通过动态分配一个queue_entry结构体，并初始化其fname为文件名fn，len为文件大小，depth为cur_depth + 1,passed_det为传递进来的passed_det。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> ck_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> queue_entry));</span><br><span class="line">q-&gt;fname = fname;</span><br><span class="line">q-&gt;len = len;</span><br><span class="line">q-&gt;depth = cur_depth + <span class="number">1</span>;</span><br><span class="line">q-&gt;passed_det = passed_det;</span><br></pre></td></tr></table></figure>

<p>如果<code>q-&gt;depth &gt; max_depth</code>，则设置max_depth为q-&gt;depth</p>
<p>如果queue_top不为空，则设置<code>queue_top-&gt;next为q，queue_top = q;</code>，否则<code>q_prev100 = queue = queue_top = q;</code></p>
<p>queue计数器<code>queued_paths</code>和待fuzz的样例计数器<code>pending_not_fuzzed</code>加一</p>
<p>cycles_wo_finds设置为0，意思是Cycles without any new paths</p>
<p>如果<code>queued_paths % 100</code>得到0，则设置<code>q_prev100-&gt;next_100 = q; q_prev100 = q;</code></p>
<p>设置last_path_time为当前时间。</p>
<h4 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Load automatically generated extras. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_auto</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u32 i;</span><br><span class="line">  <span class="comment">// USE_AUTO_EXTRAS = 50</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; USE_AUTO_EXTRAS; i++) &#123;</span><br><span class="line">    <span class="comment">// MAX_AUTO_EXTRA = 32</span></span><br><span class="line">    u8  tmp[MAX_AUTO_EXTRA + <span class="number">1</span>];</span><br><span class="line">   	<span class="comment">// 读取是否存在自动化的测试额外用例</span></span><br><span class="line">    u8* fn = alloc_printf(<span class="string">&quot;%s/.state/auto_extras/auto_%06u&quot;</span>, in_dir, i);</span><br><span class="line">    s32 fd, len;</span><br><span class="line">    fd = open(fn, O_RDONLY, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno != ENOENT) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">      ck_free(fn);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We read one byte more to cheaply detect tokens that are too</span></span><br><span class="line"><span class="comment">       long (and skip them). */</span></span><br><span class="line">    len = read(fd, tmp, MAX_AUTO_EXTRA + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to read from &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    <span class="keyword">if</span> (len &gt;= MIN_AUTO_EXTRA &amp;&amp; len &lt;= MAX_AUTO_EXTRA) <span class="comment">// 3 &lt;= len &lt;= 32</span></span><br><span class="line">      maybe_add_auto(tmp, len); <span class="comment">// 尝试添加到自动化测试额外用例</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    ck_free(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i) OKF(<span class="string">&quot;Loaded %u auto-discovered dictionary tokens.&quot;</span>, i);</span><br><span class="line">  <span class="keyword">else</span> OKF(<span class="string">&quot;No auto-generated dictionary tokens to reuse.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="maybe-add-auto"><a href="#maybe-add-auto" class="headerlink" title="maybe_add_auto"></a>maybe_add_auto</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">maybe_add_auto</span><span class="params">(u8* mem, u32 len)</span> &#123;</span><br><span class="line">  u32 i;</span><br><span class="line">  <span class="comment">/* Allow users to specify that they don&#x27;t want auto dictionaries. */</span></span><br><span class="line">  <span class="comment">// MAX_AUTO_EXTRAS 或者 USE_AUTO_EXTRAS 为0则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!MAX_AUTO_EXTRAS || !USE_AUTO_EXTRAS) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip runs of identical bytes. */</span></span><br><span class="line">  <span class="comment">// 存在和第一个字节相同的则跳出</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    <span class="keyword">if</span> (mem[<span class="number">0</span>] ^ mem[i]) <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 不存在与第一个字节相同则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (i == len) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 隔着两个字符就有和第一个字符相同的字符</span></span><br><span class="line">  <span class="comment">// 如果len的长度为2，就和interesting_16数组里的元素比较，如果和其中某一个相同，就直接return</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">    i = <span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) </span><br><span class="line">      <span class="keyword">if</span> (*((u16*)mem) == interesting_16[i] ||</span><br><span class="line">          *((u16*)mem) == SWAP16(interesting_16[i])) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 同理</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">4</span>) &#123;</span><br><span class="line">    i = <span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) </span><br><span class="line">      <span class="keyword">if</span> (*((u32*)mem) == interesting_32[i] ||</span><br><span class="line">          *((u32*)mem) == SWAP32(interesting_32[i])) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reject anything that matches existing extras. Do a case-insensitive</span></span><br><span class="line"><span class="comment">     match. We optimize by exploiting the fact that extras[] are sorted</span></span><br><span class="line"><span class="comment">     by size. */</span></span><br><span class="line">  <span class="comment">// 小到大 extras[	]</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; extras_cnt; i++)</span><br><span class="line">    <span class="keyword">if</span> (extras[i].len &gt;= len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; extras_cnt &amp;&amp; extras[i].len == len; i++)</span><br><span class="line">  	<span class="comment">// 不论大小写 如果 mem和extras[]里的元素相同，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!memcmp_nocase(extras[i].data, mem, len)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  auto_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a_extras_cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a_extras[i].len == len &amp;&amp; !memcmp_nocase(a_extras[i].data, mem, len)) &#123;</span><br><span class="line">      	<span class="comment">// 不论大小写 如果 mem和a_extras[i]里的元素相同，则a_extras[i].hit_cnt++ 这是代表在语料中被use的次数</span></span><br><span class="line">        a_extras[i].hit_cnt++;</span><br><span class="line">      <span class="keyword">goto</span> sort_a_extras;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将mem添加到a_extras中</span></span><br><span class="line">  <span class="keyword">if</span> (a_extras_cnt &lt; MAX_AUTO_EXTRAS) &#123;</span><br><span class="line">    <span class="comment">//a_extras[] 未满</span></span><br><span class="line">    a_extras = ck_realloc_block(a_extras, (a_extras_cnt + <span class="number">1</span>) *</span><br><span class="line">                                <span class="keyword">sizeof</span>(<span class="keyword">struct</span> extra_data));</span><br><span class="line">    a_extras[a_extras_cnt].data = ck_memdup(mem, len);</span><br><span class="line">    a_extras[a_extras_cnt].len  = len;</span><br><span class="line">    a_extras_cnt++;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// a_extras[]已满则随机删除a_extras[]中的一个元素</span></span><br><span class="line">    i = MAX_AUTO_EXTRAS / <span class="number">2</span> +</span><br><span class="line">        UR((MAX_AUTO_EXTRAS + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    ck_free(a_extras[i].data);</span><br><span class="line">    a_extras[i].data    = ck_memdup(mem, len);</span><br><span class="line">    a_extras[i].len     = len;</span><br><span class="line">    a_extras[i].hit_cnt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">sort_a_extras:</span><br><span class="line">  <span class="comment">/* First, sort all auto extras by use count, descending order. */</span></span><br><span class="line">  <span class="comment">// 根据hit_cnt进行降序排序</span></span><br><span class="line">  qsort(a_extras, a_extras_cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> extra_data),</span><br><span class="line">        compare_extras_use_d);</span><br><span class="line">  <span class="comment">/* Then, sort the top USE_AUTO_EXTRAS entries by size. */</span></span><br><span class="line">  <span class="comment">// 安装按大小进行排列</span></span><br><span class="line">  qsort(a_extras, MIN(USE_AUTO_EXTRAS, a_extras_cnt),</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> extra_data), compare_extras_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h4><p>逻辑上说这个函数就是为inputdir里的testcase，在output dir里创建hard link</p>
<ul>
<li>初始化<code>id=0</code></li>
<li>依次遍历<code>queue</code>里的元素q<ul>
<li>在<code>q-&gt;fname</code>里找到最后一个’&#x2F;‘所在的位置，如果找不到，则<code>rsl = q-&gt;fname</code>,否则rsl指向’&#x2F;‘后的第一个字符,其实也就是最后一个<code>/</code>后面的字符串</li>
<li>将rsl的前三个字节和<code>id_</code>进行比较<ul>
<li>如果相等，则设置<code>resuming_fuzz</code>为1,然后做一些恢复操作，不叙述。</li>
<li>如果不相等<ul>
<li>在rsl里寻找<code>,orig:</code>子串，如果找到了，将use_name指向该子串的冒号后的名字；如果没找到，就另<code>use_name = rsl</code></li>
<li><code>nfn = alloc_printf(&quot;%s/queue/id:%06u,orig:%s&quot;, out_dir, id, use_name);</code></li>
<li>尝试创建从input file到<code>alloc_printf(&quot;%s/queue/id:%06u,orig:%s&quot;, out_dir, id, use_name)</code>的硬链接</li>
</ul>
</li>
</ul>
</li>
<li>修改<code>q-&gt;fname</code>指向这个硬链接</li>
<li>如果<code>q-&gt;passed_det = 1</code>，则执行<code>mark_as_det_done(q)</code> 这主要是对应上面的resuming_fuzz的情况。<ul>
<li>mark_as_det_done简单的说就是打开<code>out_dir/queue/.state/deterministic_done/use_name</code>这个文件，如果不存在就创建这个文件，然后设置q的passed_det为1。</li>
<li>这里的<code>use_name就是orig:后面的字符串</code></li>
</ul>
</li>
</ul>
</li>
<li>如果设置了in_place_resume为1，则执行<code>nuke_resume_dir()</code><ul>
<li>nuke_resume_dir()<ul>
<li>删除<code>out_dir/_resume/.state/deterministic_done</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/auto_extras</code>文件夹下所有<code>auto_</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/redundant_edges</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/variable_behavior</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除文件夹<code>out_dir/_resume/.state</code></li>
<li>删除<code>out_dir/_resume</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>如果全部删除成功就正常返回，如果有某一个删除失败就抛出异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h4><p>如果timeout_given没有被设置，则进入find_timeout<br>这个想法是，在不指定-t的情况下resuming sessions时，我们不希望一遍又一遍地自动调整超时时间，以防止超时值因随机波动而增长</p>
<ul>
<li>如果resuming_fuzz为0，则直接return</li>
<li>如果in_place_resume为1，则<code>fn = alloc_printf(&quot;%s/fuzzer_stats&quot;, out_dir);</code>，否则<code>fn = alloc_printf(&quot;%s/../fuzzer_stats&quot;, in_dir);</code></li>
<li>以只读方式打开fd，读取内容到tmp[4096]里，并在里面搜索”exec_timeout      : “，如果搜索不到就直接返回，如果搜索到了，就读取这个timeout的数值，如果大于4就设置为exec_tmout的值。</li>
<li>timeout_given &#x3D; 3</li>
</ul>
<h4 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h4><p>执行所有的测试用例，以检查是否按预期工作</p>
<ul>
<li><code>skip_crashes = getenv(&quot;AFL_SKIP_CRASHES&quot;)</code>，设置<code>cal_failures = 0</code></li>
<li>遍历queue<ul>
<li>打开<code>q-&gt;fname</code>，并读取到分配的内存<code>use_mem</code>里，然后关闭该文件</li>
<li><code>res = calibrate_case(argv, q, use_mem, 0, 1)</code>  参数对应要测试的二进制文件，队列元素，测试字符串数据，0，1<ul>
<li>校准测试用例，见下文</li>
</ul>
</li>
<li>如果stop_soon被置为1，就直接return</li>
<li>如果res的结果为<code>crash_mode</code>或者<code>FAULT_NOBITS</code><ul>
<li>打印<code>SAYF(&quot;len = %u, map size = %u, exec speed = %llu us\n&quot;, q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</code></li>
</ul>
</li>
<li>依据res的结果查看是哪种错误并进行判断。一共有以下几种错误类型<ul>
<li><code>FAULT_NONE</code><ul>
<li>如果q是头结点，即第一个测试用例，则执行<code>check_map_coverage</code>，用以评估map coverage<ul>
<li>计数<code>trace_bits</code>发现的路径数，如果小于100，就直接返回</li>
<li>在<code>trace_bits</code>的数组后半段，如果有值就直接返回。</li>
<li>抛出警告<code>WARNF(&quot;Recompile binary with newer version of afl to improve coverage!&quot;)</code></li>
</ul>
</li>
<li>如果是<code>crash_mode</code>，则抛出异常，<code>FATAL(&quot;Test case &#39;%s&#39; does *NOT* crash&quot;, fn);</code>，该文件不崩溃</li>
</ul>
</li>
<li><code>FAULT_TMOUT</code><ul>
<li>如果指定了-t参数，则<code>timeout_given = 2</code><ul>
<li>抛出警告<code>WARNF(&quot;Test case results in a timeout (skipping)&quot;);</code>，并设置<code>q-&gt;cal_failed = CAL_CHANCES</code>，<code>cal_failures++</code></li>
</ul>
</li>
</ul>
</li>
<li><code>FAULT_CRASH</code><ul>
<li>设置了crash_mode则return</li>
<li>如果没有指定<code>mem_limit</code>，则可能抛出建议增加内存的建议</li>
<li>但不管指定了还是没有，都会抛出异常<code>FATAL(&quot;Test case &#39;%s&#39; results in a crash&quot;, fn);</code></li>
</ul>
</li>
<li><code>FAULT_ERROR</code><ul>
<li>抛出异常<code>Unable to execute target application</code></li>
</ul>
</li>
<li><code>FAULT_NOINST</code><ul>
<li>这个样例运行没有出现任何路径信息，抛出异常<code>No instrumentation detected</code></li>
</ul>
</li>
<li><code>FAULT_NOBITS</code> <ul>
<li>如果这个样例有出现路径信息，但是没有任何新路径，抛出警告<code>WARNF(&quot;No new instrumentation output, test case may be useless.&quot;)</code>，认为这是无用路径。useless_at_start计数器加一</li>
</ul>
</li>
</ul>
</li>
<li>如果这个样例q的<code>var_behavior</code>为真，则代表它多次运行，同样的输入条件下，却出现不同的覆盖信息。<ul>
<li>抛出警告<code>WARNF(&quot;Instrumentation output varies across runs.&quot;);</code>，代表这个样例的路径输出可变</li>
</ul>
</li>
<li>然后读取下一个queue，继续测试，直到结束</li>
</ul>
</li>
<li>最后是对<code>cal_failures</code> 校准失败次数的处理</li>
</ul>
<h4 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h4><p>这个函数评估input文件夹下的case，来发现这些testcase的行为是否异常；以及在发现新的路径时，用以评估这个新发现的testcase的行为是否是可变（这里的可变是指多次执行这个case，发现的路径不同）等等</p>
<ul>
<li><p>这个函数的参数为<code>char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue</code></p>
</li>
<li><p>创建<code>first_trace[MAP_SIZE]</code></p>
</li>
<li><p>如果q-&gt;exec_cksum (Checksum of the execution trace)为0，代表这是这个case第一次运行，即来自input文件夹下，所以将<code>first_run</code>置为1。</p>
</li>
<li><p>保存原有的stage_cur、stage_max、stage_name</p>
</li>
<li><p>设置use_tmout为exec_tmout,如果from_queue是0或者resuming_fuzz被置为1，即代表不来自于queue中或者在resuming sessions的时候，则use_tmout的值被设置的更大。</p>
</li>
<li><p><code>q-&gt;cal_failed++</code></p>
</li>
<li><p>设置stage_name为”calibration”,以及根据是否fast_cal为1，来设置stage_max的值为3还是<code>CAL_CYCLES</code>(默认为8)，stage_max含义是每个新测试用例（以及显示出可变行为的测试用例）的校准周期数，也就是说这个stage要执行几次的意思。</p>
</li>
<li><p>如果当前不是以dumb mode运行，且no_forkserver（禁用forkserver）为0，且forksrv_pid为0，则<code>init_forkserver(argv)</code>启动fork server，见后文。</p>
</li>
<li><p>此时<code>q-&gt;exec_cksum</code>不为空，拷贝trace_bits到first_trace里，然后计算<code>has_new_bits(virgin_bits)</code>的值和new_bits比较，如果大于new_bits，则将该值赋给new_bits。</p>
</li>
<li><p>开始执行calibration stage，共执行stage_max轮</p>
<ul>
<li><p>如果不是第一次执行，根据更新频率来刷新展示界面<code>show_stats</code>，用来展示这次执行的结果。</p>
</li>
<li><p>write_to_testcase(use_mem, q-&gt;len)</p>
<ul>
<li>将从<code>q-&gt;fname</code>中读取的内容写入到<code>.cur_input</code>中</li>
</ul>
</li>
<li><p><code>fault = run_target(argv, use_tmout)</code></p>
</li>
<li><p>&#96;&#96;&#96;c<br>if (stop_soon || fault !&#x3D; crash_mode) goto abort_calibration; &#x2F;&#x2F; stop_soon 由ctrl + c 设置<br>if (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) { &#x2F;&#x2F; 不是哑巴模式并且在第一次校准周期内 count_bytes(trace_bits) 为0<br>  fault &#x3D; FAULT_NOINST;<br>  goto abort_calibration;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 计算`hash32(trace_bits, MAP_SIZE, HASH_CONST)`的结果，其值为一个32位uint值，保存到`cksum`中</span><br><span class="line"></span><br><span class="line">  - 如果`q-&gt;exec_cksum`不等于cksum，即代表这是第一次运行，或者在相同的参数下，每次执行，cksum却不同，是一个路径可变的queue</span><br><span class="line"></span><br><span class="line">    - `hnb = has_new_bits(virgin_bits)`</span><br><span class="line">    - 如果hnb大于new_bits，设置new_bits的值为hnb</span><br><span class="line">    - 如果`q-&gt;exec_cksum`不等于0，即代表这是判断是否是可变queue</span><br><span class="line">      - i从0到MAP_SIZE遍历，如果first_trace[i]不等于trace_bits[i]，**代表发现了可变queue**，且var_bytes为空，则将该字节设置为1，并将stage_max设置为`CAL_CYCLES_LONG`，即需要执行40次。</span><br><span class="line">      - 将`var_detected`设置为1</span><br><span class="line">    - 否则，即q-&gt;exec_cksum等于0，即代表这是第一次执行这个queue</span><br><span class="line">      - 设置`q-&gt;exec_cksum`的值为之前计算出来的本次执行的cksum</span><br><span class="line">      - 拷贝`trace_bits`到`first_trace`中。</span><br><span class="line"></span><br><span class="line">- stage_max轮循环结束</span><br><span class="line"></span><br><span class="line">- 保存所有轮次总的执行时间，加到`total_cal_us`里，总的执行轮次，加到`total_cal_cycles`里</span><br><span class="line"></span><br><span class="line">- 计算出一些统计信息，包括</span><br><span class="line"></span><br><span class="line">  - 计算出单次执行时间的平均值保存到q-&gt;exec_us里</span><br><span class="line">  - 将最后一次执行所覆盖到的路径数保存到q-&gt;bitmap_size里</span><br><span class="line">  - `q-&gt;handicap = handicap;`</span><br><span class="line">  - `q-&gt;cal_failed = 0;`</span><br><span class="line">  - total_bitmap_size里加上这个queue所覆盖到的路径数</span><br><span class="line">  - total_bitmap_entries++</span><br><span class="line">  - update_bitmap_score(struct queue_entry *q)</span><br><span class="line"></span><br><span class="line">- 如果fault为`FAULT_NONE`，且该queue是第一次执行，且不属于dumb_mode，而且new_bits为0，代表在这个样例所有轮次的执行里，都没有发现任何新路径和出现异常，设置fault为`FAULT_NOBITS`</span><br><span class="line"></span><br><span class="line">- 如果new_bits为2，且`q-&gt;has_new_cov`为0，设置其值为1，并将queued_with_cov加一，代表有一个queue发现了新路径。</span><br><span class="line"></span><br><span class="line">- 如果这个queue是可变路径，即var_detected为1，则计算var_bytes里被置位的tuple个数，保存到`var_byte_count`里，代表这些tuple具有可变的行为。</span><br><span class="line"></span><br><span class="line">  - 将这个queue标记为一个variable</span><br><span class="line">  - mark_as_variable(struct queue_entry *q)</span><br><span class="line">    - 创建符号链接`out_dir/queue/.state/variable_behavior/fname`</span><br><span class="line">    - 设置queue的var_behavior为1</span><br><span class="line">  - 计数variable behavior的计数器`queued_variable`的值加一</span><br><span class="line"></span><br><span class="line">- 恢复之前的stage值</span><br><span class="line"></span><br><span class="line">- 如果不是第一次运行这个queue，展示`show_stats`</span><br><span class="line"></span><br><span class="line">- 返回fault的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### init_forkserver</span><br><span class="line"></span><br><span class="line">建立管道st_pipe和ctl_pipe，在父子进程之间，是通过管道进行通信，一个用于传递状态，另一个用于传递命令。然后进行执行fork。</span><br><span class="line"></span><br><span class="line">`forksrv_pid = fork()`</span><br><span class="line"></span><br><span class="line">##### 子进程部分</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">  if (!forksrv_pid) &#123;</span><br><span class="line">	// 子进程进入</span><br><span class="line">    struct rlimit r;</span><br><span class="line">    /* Umpf. On OpenBSD, the default fd limit for root users is set to</span><br><span class="line">       soft 128. Let&#x27;s try to fix that... */</span><br><span class="line">	// 获取最大文件描述符个数，如果最大文件描述符个数 小于 FORKSRV_FD + 2 则将最大文件描述符设置成更大的值</span><br><span class="line">    if (!getrlimit(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + 2) &#123;</span><br><span class="line">      r.rlim_cur = FORKSRV_FD + 2;</span><br><span class="line">      setrlimit(RLIMIT_NOFILE, &amp;r); /* Ignore errors */</span><br><span class="line">    &#125;</span><br><span class="line">    if (mem_limit) &#123; // 内存限制</span><br><span class="line">      r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) &lt;&lt; 20;</span><br><span class="line">#ifdef RLIMIT_AS</span><br><span class="line">	  // RLIMIT_AS                进程可用存储区的最大总长度（字节）。这回影响sbrk函数和mmap函数</span><br><span class="line">      setrlimit(RLIMIT_AS, &amp;r); /* Ignore errors */</span><br><span class="line">#else</span><br><span class="line"> 	  // RLIMIT_DATA            数据段的最大字节长度。这是初始化数据、非初始化数据以及堆的总和</span><br><span class="line">      setrlimit(RLIMIT_DATA, &amp;r); /* Ignore errors */</span><br><span class="line">#endif /* ^RLIMIT_AS */</span><br><span class="line">    &#125;</span><br><span class="line">    r.rlim_max = r.rlim_cur = 0;</span><br><span class="line">	// RLIMIT_CORE           core文件的最大字节数，若其值为0则阻止创建core文件。</span><br><span class="line">	// 阻止其生成core文件</span><br><span class="line">    setrlimit(RLIMIT_CORE, &amp;r); /* Ignore errors */</span><br><span class="line">    setsid(); // setsid()调用成功后，返回新的会话的ID，调用setsid函数的进程成为新的会话的领头进程，并与其父进程的会话组和进程组脱离。</span><br><span class="line"></span><br><span class="line">    dup2(dev_null_fd, 1); // 重定向标准输出和标准错误到 /dev/null</span><br><span class="line">    dup2(dev_null_fd, 2);</span><br><span class="line"></span><br><span class="line">    if (out_file) &#123;</span><br><span class="line">      dup2(dev_null_fd, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dup2(out_fd, 0);</span><br><span class="line">      close(out_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dup2(ctl_pipe[0], FORKSRV_FD) &lt; 0) PFATAL(&quot;dup2() failed&quot;); // 读控制命令</span><br><span class="line">    if (dup2(st_pipe[1], FORKSRV_FD + 1) &lt; 0) PFATAL(&quot;dup2() failed&quot;); // 写状态</span><br><span class="line"></span><br><span class="line">    close(ctl_pipe[0]);</span><br><span class="line">    close(ctl_pipe[1]);</span><br><span class="line">    close(st_pipe[0]);</span><br><span class="line">    close(st_pipe[1]);</span><br><span class="line"></span><br><span class="line">    close(out_dir_fd);</span><br><span class="line">    close(dev_null_fd);</span><br><span class="line">    close(dev_urandom_fd);</span><br><span class="line">    close(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">    if (!getenv(&quot;LD_BIND_LAZY&quot;)) setenv(&quot;LD_BIND_NOW&quot;, &quot;1&quot;, 0);</span><br><span class="line"></span><br><span class="line">    setenv(&quot;ASAN_OPTIONS&quot;, &quot;abort_on_error=1:&quot;</span><br><span class="line">                           &quot;detect_leaks=0:&quot;</span><br><span class="line">                           &quot;symbolize=0:&quot;</span><br><span class="line">                           &quot;allocator_may_return_null=1&quot;, 0);</span><br><span class="line"></span><br><span class="line">    setenv(&quot;MSAN_OPTIONS&quot;, &quot;exit_code=&quot; STRINGIFY(MSAN_ERROR) &quot;:&quot;</span><br><span class="line">                           &quot;symbolize=0:&quot;</span><br><span class="line">                           &quot;abort_on_error=1:&quot;</span><br><span class="line">                           &quot;allocator_may_return_null=1:&quot;</span><br><span class="line">                           &quot;msan_track_origins=0&quot;, 0);</span><br><span class="line"></span><br><span class="line">    execv(target_path, argv); // 执行</span><br><span class="line"></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG; //使用一个独特的bitmaps EXEC_FAIL_SIG(0xfee1dead)写入trace_bits，来告诉父进程执行失败，并结束子进程。</span><br><span class="line">    exit(0);</span><br><span class="line"></span><br><span class="line">  &#125; // 子进程</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="父进程部分"><a href="#父进程部分" class="headerlink" title="父进程部分"></a>父进程部分</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭不是需要的endpoints</span></span><br><span class="line">close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];<span class="comment">//父进程只能发送(&quot;写出&quot;)命令</span></span><br><span class="line">fsrv_st_fd = st_pipe[<span class="number">0</span>];<span class="comment">//父进程只能读取状态</span></span><br></pre></td></tr></table></figure>

<ul>
<li>等待fork server启动，但是不能等太久。（所以在调试时要注意这个…）<ul>
<li>从管道里读取4个字节到status里，如果读取成功，则代表fork server成功启动，就结束这个函数并返回。</li>
<li>如果超时，就抛出异常。</li>
</ul>
</li>
</ul>
<p>后续是一些子进程启动失败的异常处理逻辑，暂时不叙</p>
<h4 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits"></a>has_new_bits</h4><ul>
<li>检查有没有新路径或者某个路径的执行次数有所不同。</li>
<li>初始化current和virgin为trace_bits和virgin_map的u64首元素地址，设置ret的值为0</li>
<li>8个字节一组，每次从trace_bits，也就是共享内存里取出8个字节<ul>
<li>如果current不为0，且current &amp; virgin 不为0，即代表current发现了新路径或者某条路径的执行次数和之前有所不同<ul>
<li>如果ret当前小于2<ul>
<li>取current的首字节地址为cur，virgin的首字节地址为vir</li>
<li>i的范围是0-7，比较cur[i] &amp;&amp; vir[i] &#x3D;&#x3D; 0xff，如果有一个为真，则设置ret为2<ul>
<li>这代表发现了之前没有出现过的tuple</li>
<li><strong>注意&#x3D;&#x3D;的优先级比&amp;&amp;要高，所以先判断vir[i]是否是0xff，即之前从未被覆盖到，然后再和cur[i]进行逻辑与</strong></li>
</ul>
</li>
<li>否则设置ret为1<ul>
<li>这代表仅仅只是改变了某个tuple的hit-count</li>
</ul>
</li>
</ul>
</li>
<li><code>*virgin &amp;= ~*current</code> 更新bitmap</li>
</ul>
</li>
<li>current和virgin移动到下一组8个字节，直到MAPSIZE全被遍历完。</li>
</ul>
</li>
<li>如果传入给has_new_bits的参数virgin_map是virgin_bits,且ret不为0，就设置bitmap_changed为1</li>
<li>返回ret的值。</li>
</ul>
<h4 id="run-target"><a href="#run-target" class="headerlink" title="run_target"></a>run_target</h4><ul>
<li>先清空<code>trace_bits[MAP_SIZE]</code>，将其全置为0，也就是清空共享内存。</li>
<li>如果<code>dumb_mode = 1</code>，且no_forkserver，则直接fork出一个子进程，然后让子进程execv去执行target，如果execv执行失败，则向trace_bits写入<code>EXEC_FAIL_SIG</code></li>
<li>否则，就向控制管道写入<code>prev_timed_out</code>的值，命令Fork server开始fork出一个子进程进行fuzz，然后从状态管道读取fork server返回的fork出的子进程的ID到<code>child_pid</code> (这里是和_afl_maybe_log想对应的)</li>
<li>无论实际执行的是上面两种的哪一种，在执行target期间，都设置计数器为timeout，如果超时，就杀死正在执行的子进程，并设置child_timed_out为1;</li>
<li>计算target执行时间exec_ms，并将total_execs这个执行次数计数器加一。</li>
<li>等待target执行结束，如果是<code>dumb_mode == 1 || no_forkserver</code>，target执行结束的状态码将直接保存到status中，如果不是则从状态管道中读取target执行结束的状态码。</li>
<li><code>if (!WIFSTOPPED(status)) child_pid = 0;</code> 如果状态码是STOP</li>
<li>classify_counts((u64 *) trace_bits)<ul>
<li>具体地，target是将每个分支的执行次数用1个byte来储存，而fuzzer则进一步把这个执行次数归入到buckets中，举个例子，如果某分支执行了1次，那么落入第2个bucket，其计数byte仍为1；如果某分支执行了4次，那么落入第5个bucket，其计数byte将变为8，等等。</li>
<li>这样处理之后，对分支执行次数就会有一个简单的归类。例如，如果对某个测试用例处理时，分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。当然，这样的简单分类肯定不能区分所有的情况，不过在某种程度上，处理了一些因为循环次数的微小区别，而误判为不同执行结果的情况.</li>
</ul>
</li>
<li>设置prev_timed_out的值为child_timed_out。</li>
<li>接着依据status的值，向调用者返回结果。</li>
</ul>
<h4 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h4><p>每当我们发现一个新的路径，都会调用这个函数来判断其是不是更加地favorable，这个favorable的意思是说是否包含最小的路径集合来遍历到所有bitmap中的位，我们专注于这些集合而忽略其他的。</p>
<ul>
<li>首先计算出这个case的fav_factor，计算方法是<code>q-&gt;exec_us * q-&gt;len</code>即执行时间和样例大小的乘积，以这两个指标来衡量权重。</li>
<li>遍历trace_bits数组，如果该字节的值不为0，则代表这是已经被覆盖到的path<ul>
<li>然后检查对应于这个path的top_rated是否存在<ul>
<li>如果存在，就比较<code>fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len</code>，即比较执行时间和样例大小的乘积，哪个更小。<ul>
<li>如果<code>top_rated[i]</code>的更小，则代表<code>top_rated[i]</code>的更优，不做任何处理，继续遍历下一个path。</li>
<li>如果q更小，就将<code>top_rated[i]</code>原先对应的queue entry的tc_ref字段减一，并将其trace_mini字段置为空。</li>
</ul>
</li>
<li>然后设置<code>top_rated[i]</code>为q，即当前case，然后将其tc_ref的值加一</li>
<li>如果<code>q-&gt;trace_mini</code>为空，则将trace_bits经过minimize_bits压缩，然后存到trace_mini字段里 即byte到bit的映射</li>
<li>设置score_changed为1.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h4><p>精简队列</p>
<ul>
<li><p>如果<code>score_changed</code>为0，即<code>top_rated</code>没有变化，或者<code>dumb_mode</code>,就直接返回</p>
</li>
<li><p>设置<code>score_changed</code>的值为0</p>
</li>
<li><p>创建u8 temp_v数组，大小为<code>MAP_SIZE除8</code>，并将其初始值设置为0xff，其每位如果为1就代表还没有被覆盖到，如果为0就代表以及被覆盖到了。</p>
</li>
<li><p>设置queued_favored为0，pending_favored为0</p>
</li>
<li><p>开始遍历queue队列，设置其favored的值都为0</p>
</li>
<li><p>将i从0到MAP_SIZE迭代，这个迭代其实就是筛选出一组queue entry，它们就能够覆盖到所有现在已经覆盖到的路径，而且这个case集合里的case要更小更快，这并不是最优算法，只能算是贪婪算法。</p>
</li>
<li><p>如果top_rated[i]有值，且该path在temp_v里被置位</p>
<ul>
<li>就从temp_v中清除掉所有<code>top_rated[i]</code>覆盖到的path，将对应的bit置为0</li>
<li>设置<code>top_rated[i]-&gt;favored</code>为1，queued_favored计数器加一</li>
<li>如果<code>top_rated[i]</code>的was_fuzzed字段是0，代表其还没有fuzz过，则将pending_favored计数器加一</li>
</ul>
</li>
<li><p>遍历queue队列</p>
<ul>
<li>mark_as_redundant(q, !q-&gt;favored)<ul>
<li>也就是说，如果不是favored的case，就被标记成redundant_edges</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="mark-as-redundant"><a href="#mark-as-redundant" class="headerlink" title="mark_as_redundant"></a>mark_as_redundant</h4><p><code>mark_as_redundant(struct queue_entry* q, u8 state)</code></p>
<ul>
<li>如果<code>state和q-&gt;fs_redundant</code>相等，就直接返回</li>
<li>设置<code>q-&gt;fs_redundant</code>的值为state，</li>
<li>如果state为0<ul>
<li>尝试删除<code>out_dir/queue/.state/redundant_edges/fname</code></li>
</ul>
</li>
</ul>
<h4 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h4><ul>
<li>如果<code>pending_favored</code>不为0，则对于queue_cur被fuzz过或者不是favored的，有99%的几率直接返回1。</li>
<li>如果<code>pending_favored</code>为0且<code>!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; 10</code><ul>
<li>如果queue_cycle大于1且queue_cur没有被fuzz过，则有75%的概率直接返回1</li>
<li>如果queue_cur被fuzz过，否则有95%的概率直接返回1</li>
</ul>
</li>
<li>设置len为<code>queue_cur-&gt;len</code></li>
<li>打开该case对应的文件，并通过mmap映射到内存里，地址赋值给<code>in_buf</code>和<code>orig_in</code></li>
<li>分配len大小的内存，并初始化为全0，然后将地址赋值给out_buf</li>
</ul>
<h5 id="CALIBRATION阶段"><a href="#CALIBRATION阶段" class="headerlink" title="CALIBRATION阶段"></a><strong>CALIBRATION阶段</strong></h5><ul>
<li>假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case再次校准。</li>
</ul>
<h5 id="TRIMMING阶段"><a href="#TRIMMING阶段" class="headerlink" title="TRIMMING阶段"></a><strong>TRIMMING阶段</strong></h5><ul>
<li><p>如果该case没有trim过，</p>
<ul>
<li><p>调用函数<code>trim_case(argv, queue_cur, in_buf)</code>进行trim(修剪)</p>
</li>
<li><p>设置queue_cur的trim_done为1</p>
</li>
<li><p>重新读取一次<code>queue_cur-&gt;len</code>到len中</p>
</li>
</ul>
</li>
<li><p>将in_buf拷贝len个字节到out_buf中</p>
</li>
</ul>
<h5 id="PERFORMANCE-SCORE阶段"><a href="#PERFORMANCE-SCORE阶段" class="headerlink" title="PERFORMANCE SCORE阶段"></a><strong>PERFORMANCE SCORE阶段</strong></h5><ul>
<li><p>perf_score &#x3D; <code>calculate_score(queue_cur)</code></p>
</li>
<li><p>如果skip_deterministic为1，或者queue_cur被fuzz过，或者queue_cur的passed_det为1，则跳转去havoc_stage阶段</p>
</li>
<li><p>设置doing_det为1</p>
</li>
</ul>
<h5 id="SIMPLE-BITFLIP-dictionary-construction-阶段"><a href="#SIMPLE-BITFLIP-dictionary-construction-阶段" class="headerlink" title="SIMPLE BITFLIP (+dictionary construction)阶段"></a><strong>SIMPLE BITFLIP (+dictionary construction)阶段</strong></h5><ul>
<li>下面这个宏很有意思</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line"><span class="meta">    u8* _arf = (u8*)(_ar); \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b); \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FLIP_BIT(out_buf, stage_cur)</span></span><br><span class="line"><span class="comment">// _ar的取值是out_buf,而_bf的取值在[0: len &lt;&lt; 3]。</span></span><br><span class="line"><span class="comment">// 所以用`_bf &amp; 7`能够得到`0,1,2...7 0,1,2...7`这样的取值一共len组，</span></span><br><span class="line"><span class="comment">// 然后`(_bf) &gt;&gt; 3`又将[0: len&lt;&lt;3]映射回了[0: len)，对应到buf里的每个byte。即buf中的数据每一个bit都会翻转一次。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置stage_name为<code>bitflip 1/1</code></p>
</li>
<li><p>进入循环，循环次数为buf中有多少个bit</p>
<ul>
<li><p>依次将每个位翻转，然后执行一次<code>common_fuzz_stuff</code>，然后再翻转回来。</p>
</li>
<li><p>在进行bitflip 1&#x2F;1变异时，对于每个byte的最低位(least significant  bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。<br>比如对于SQL的<code>SELECT *</code>，如果<code>SELECT</code>被破坏，则肯定和正确的路径不一致，而被破坏之后的路径却肯定是一样的，比如<code>AELECT</code>和<code>SBLECT</code>，显然都是无意义的，而只有不破坏token，才有可能出现和原始执行路径一样的结果，所以AFL在这里就是在猜解关键字token。</p>
</li>
<li><p>token默认最小是3，最大是32,每次发现新token时，通过<code>maybe_add_auto</code>添加到<code>a_extras</code>数组里</p>
</li>
</ul>
</li>
<li><p><code>stage_cycles[STAGE_FLIP1]</code>的值加上在整个<code>FLIP_BIT</code>中执行的target次数stage_max</p>
</li>
<li><p><code>stage_finds[STAGE_FLIP1]</code>的值加上在整个<code>FLIP_BIT</code>中新发现的路径和Crash总和</p>
</li>
<li><p>设置stage_name为<code>bitflip 2/1</code>,原理和之前一样，只是这次是连续翻转相邻的两位，然后保存结果到<code>stage_finds[STAGE_FLIP2]和stage_cycles[STAGE_FLIP2]</code>里。</p>
</li>
<li><p>同理，设置stage_name为<code>bitflip 4/1</code>，翻转连续的四位并记录</p>
</li>
<li><p>生成effector map</p>
<ul>
<li>在进行bitflip 8&#x2F;8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。</li>
<li>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</li>
<li>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector  map，跳过那些“无效”的byte，从而节省了执行资源。</li>
<li>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。</li>
<li>不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关：</li>
</ul>
</li>
<li><p>设置stage_name为<code>bitflip 8/8</code>，以字节为单位，直接通过和<code>0xff</code>亦或运算去翻转整个字节的位，然后执行一次，并记录。</p>
</li>
<li><p>设置stage_name为<code>bitflip 16/8</code>，设置<code>stage_max</code>为<code>len - 1</code>，以字为单位和<code>0xffff</code>进行亦或运算，去翻转相邻的两个字节(即一个字的)的位。</p>
<ul>
<li>这里要注意在翻转之前会先检查eff_map里对应于这两个字节的标志是否为0，如果为0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一个字。</li>
<li>common_fuzz_stuff执行变异后的结果，然后还原。</li>
</ul>
</li>
<li><p>同理，设置stage_name为<code>bitflip 32/8</code>，然后设置<code>stage_max</code>为<code>len - 3</code>，以双字为单位，直接通过和<code>0xffffffff</code>亦或运算去相邻四个字节的位，然后执行一次，并记录。</p>
<ul>
<li>在每次翻转之前会检查eff_map里对应于这四个字节的标志是否为0，如果是0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一组双字。</li>
</ul>
</li>
</ul>
<h5 id="ARITHMETIC-INC-x2F-DEC"><a href="#ARITHMETIC-INC-x2F-DEC" class="headerlink" title="ARITHMETIC INC&#x2F;DEC"></a><strong>ARITHMETIC INC&#x2F;DEC</strong></h5><ul>
<li>在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段：</li>
<li>arith 8&#x2F;8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</li>
<li>arith 16&#x2F;8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</li>
<li>arith 32&#x2F;8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</li>
</ul>
<p>加减变异的上限，在config.h中的宏ARITH_MAX定义，默认为35。所以，对目标整数会进行+1, +2, …, +35,  -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</p>
<p>此外，AFL还会智能地跳过某些arithmetic变异。第一种情况就是前面提到的effector  map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加&#x2F;减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</p>
<h5 id="INTERESTING-VALUES"><a href="#INTERESTING-VALUES" class="headerlink" title="INTERESTING VALUES"></a><strong>INTERESTING VALUES</strong></h5><p>下一个阶段是interest，具体可分为：</p>
<ul>
<li>interest 8&#x2F;8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</li>
<li>interest 16&#x2F;8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</li>
<li>interest 32&#x2F;8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</li>
</ul>
<p>而用于替换的”interesting values”，是AFL预设的一些比较特殊的数,这些数的定义在config.h文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static s8  interesting_8[]  = &#123; INTERESTING_8 &#125;;</span><br><span class="line">static s16 interesting_16[] = &#123; INTERESTING_8, INTERESTING_16 &#125;;</span><br><span class="line">static s32 interesting_32[] = &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;</span><br></pre></td></tr></table></figure>

<p>与之前类似，effector map仍然会用于判断是否需要变异；此外，如果某个interesting value，是可以通过bitflip或者arithmetic变异达到，那么这样的重复性变异也是会跳过的。</p>
<h5 id="DICTIONARY-STUFF"><a href="#DICTIONARY-STUFF" class="headerlink" title="DICTIONARY STUFF"></a><strong>DICTIONARY STUFF</strong></h5><p>进入到这个阶段，就接近deterministic fuzzing的尾声了。具体有以下子阶段：</p>
<p>user extras(over),从头开始,将用户提供的tokens依次替换到原文件中,stage_max为<code>extras_cnt * len</code></p>
<p>user extras(insert),从头开始,将用户提供的tokens依次插入到原文件中,stage_max为<code>extras_cnt * len</code></p>
<p>auto extras(over),从头开始,将自动检测的tokens依次替换到原文件中,stage_max为<code>MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len</code></p>
<p>其中，用户提供的tokens，是在词典文件中设置并通过-x选项指定的，如果没有则跳过相应的子阶段。</p>
<h5 id="RANDOM-HAVOC"><a href="#RANDOM-HAVOC" class="headerlink" title="RANDOM HAVOC"></a><strong>RANDOM HAVOC</strong></h5><p>对于非dumb mode的主fuzzer来说，完成了上述deterministic fuzzing后，便进入了充满随机性的这一阶段；对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始。</p>
<p>havoc，顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</p>
<p>随机选取某个bit进行翻转</p>
<p>随机选取某个byte，将其设置为随机的interesting value</p>
<p>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</p>
<p>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</p>
<p>随机选取某个byte，对其减去一个随机数</p>
<p>随机选取某个byte，对其加上一个随机数</p>
<p>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</p>
<p>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</p>
<p>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</p>
<p>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</p>
<p>随机选取某个byte，将其设置为随机数</p>
<p>随机删除一段bytes</p>
<p>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</p>
<p>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</p>
<p>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</p>
<p>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</p>
<p>怎么样，看完上面这么多的“随机”，有没有觉得晕？还没完，AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一个（可以参考高中数学的有放回摸球），依次作用到文件上。如此这般丧心病狂的变异，原文件就大概率面目全非了，而这么多的随机性，也就成了fuzzing过程中的不可控因素，即所谓的“看天吃饭”了。</p>
<p>splice</p>
<p>设置ret_val的值为0</p>
<p>如果queue_cur通过了评估，且was_fuzzed字段是0，就设置<code>queue_cur-&gt;was_fuzzed</code>为1，然后pending_not_fuzzed计数器减一</p>
<p>如果queue_cur是favored, pending_favored计数器减一。</p>
<h4 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers"></a>sync_fuzzers</h4><p>这个函数其实就是读取其他sync文件夹下的queue文件，然后保存到自己的queue里。</p>
<ul>
<li>打开<code>sync_dir</code>文件夹</li>
<li>while循环读取该文件夹下的目录和文件<code>while ((sd_ent = readdir(sd)))</code><ul>
<li>跳过<code>.</code>开头的文件和<code>sync_id</code>即我们自己的输出文件夹</li>
<li>读取<code>out_dir/.synced/sd_ent-&gt;d_name</code>文件即<code>id_fd</code>里的前4个字节到<code>min_accept</code>里，设置<code>next_min_accept</code>为<code>min_accept</code>，这个值代表之前从这个文件夹里读取到的最后一个queue的id。</li>
<li>设置stage_name为<code>sprintf(stage_tmp, &quot;sync %u&quot;, ++sync_cnt);</code>，设置stage_cur为0，stage_max为0</li>
<li>循环读取<code>sync_dir/sd_ent-&gt;d_name/queue</code>文件夹里的目录和文件<ul>
<li>同样跳过<code>.</code>开头的文件和标识小于min_accept的文件，因为这些文件应该已经被sync过了。</li>
<li>如果标识<code>syncing_case</code>大于等于next_min_accept，就设置next_min_accept为<code>syncing_case + 1</code></li>
<li>开始同步这个case<ul>
<li>如果case大小为0或者大于MAX_FILE(默认是1M),就不进行sync。</li>
<li>否则mmap这个文件到内存mem里，然后write_to_testcase(mem, st.st_size),并run_target,然后通过save_if_interesting来决定是否要导入这个文件到自己的queue里，如果发现了新的path，就导入。<ul>
<li>设置syncing_party的值为<code>sd_ent-&gt;d_name</code></li>
<li>如果save_if_interesting返回1，queued_imported计数器就加1</li>
</ul>
</li>
</ul>
</li>
<li>stage_cur计数器加一，如果stage_cur是stats_update_freq的倍数，就刷新一次展示界面。</li>
</ul>
</li>
<li>向id_fd写入当前的<code>next_min_accept</code>值</li>
</ul>
</li>
<li>总结来说，这个函数就是先读取有哪些fuzzer文件夹，然后读取其他fuzzer文件夹下的queue文件夹里的case，并依次执行，如果发现了新path，就保存到自己的queue文件夹里，而且将最后一个sync的case id写入到<code>.synced/其他fuzzer文件夹名</code>文件里，以避免重复运行。</li>
</ul>
<h4 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a>trim_case</h4><ul>
<li>如果这个case的大小len小于5字节，就直接返回</li>
<li>设置stage_name的值为tmp，在bytes_trim_in的值里加上len，bytes_trim_in代表被trim过的字节数</li>
<li>计算len_p2，其值是大于等于q-&gt;len的第一个2的幂次。（eg.如果len是5704,那么len_p2就是8192）</li>
<li>取<code>len_p2的1/16</code>为remove_len，这是起始步长。</li>
<li>进入while循环，终止条件是remove_len小于终止步长len_p2的1&#x2F;1024,每轮循环步长会除2.<ul>
<li>设置remove_pos的值为remove_len</li>
<li>读入<code>&quot;trim %s/%s&quot;, DI(remove_len), DI(remove_len)</code>到tmp中, 即stage_name &#x3D; “trim 512&#x2F;512”</li>
<li>设置stage_cur为0，stage_max为<code>q-&gt;len / remove_len</code></li>
<li>进入while循环，remove_pos &lt; q-&gt;len,即每次前进remove_len个步长，直到整个文件都被遍历完为止。<ul>
<li>由in_buf中remove_pos处开始，向后跳过remove_len个字节，写入到<code>.cur_input</code>里，然后运行一次<code>fault = run_target</code>，trim_execs计数器加一</li>
<li>由所得trace_bits计算出一个cksum，和q-&gt;exec_cksum比较<ul>
<li>如果相等<ul>
<li>从<code>q-&gt;len</code>中减去remove_len个字节，并由此重新计算出一个<code>len_p2</code>，这里注意一下<code>while (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES))</code></li>
<li>将<code>in_buf+remove_pos+remove_len</code>到最后的字节，前移到<code>in_buf+remove_pos</code>处，等于删除了remove_pos向后的remove_len个字节。</li>
<li>如果needs_write为0，则设置其为1，并保存当前trace_bits到clean_trace中。</li>
</ul>
</li>
<li>如果不相等<ul>
<li>remove_pos加上remove_len，即前移remove_len个字节。<strong>注意，如果相等，就无需前移</strong></li>
</ul>
</li>
</ul>
</li>
<li>注意trim过程可能比较慢，所以每执行stats_update_freq次，就刷新一次显示界面<code>show_stats</code></li>
<li>stage_cur加一</li>
</ul>
</li>
</ul>
</li>
<li>如果needs_write为1<ul>
<li>删除原来的q-&gt;fname，创建一个新的q-&gt;fname，将in_buf里的内容写入，然后用clean_trace恢复trace_bits的值。</li>
<li>进行一次update_bitmap_score</li>
</ul>
</li>
<li>返回fault</li>
</ul>
<h4 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score"></a>calculate_score</h4><p>根据queue entry的执行速度、覆盖到的path数和路径深度来评估出一个得分，这个得分perf_score在后面havoc的时候使用。<br>前面的没什么好说的，这里的<code>q-&gt;depth</code>解释一下，它在每次add_to_queue的时候，会设置为<code>cur_depth+1</code>，而cur_depth是一个全局变量，一开始的初始值为0。</p>
<ul>
<li>处理输入时<ul>
<li>在read_testcases的时候会调用add_to_queue，此时所有的input case的queue depth都会被设置为1。</li>
</ul>
</li>
<li>fuzz_one时<ul>
<li>然后在后面fuzz_one的时候，会先设置cur_depth为当前queue的depth，然后这个queue经过mutate之后调用save_if_interesting,如果是interesting  case，就会被add_to_queue，此时就建立起了queue之间的关联关系，所以由当前queue变异加入的新queue，深度都在当前queue的基础上再增加。</li>
</ul>
</li>
</ul>
<h4 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h4><p>简单的说就是写入文件并执行，然后处理结果，如果出现错误，就返回1.</p>
<ul>
<li>如果定义了post_handler,就通过out_buf &#x3D; post_handler(out_buf, &amp;len)处理一下out_buf，如果out_buf或者len有一个为0，则直接返回0<ul>
<li><strong>这里其实很有价值，尤其是如果需要对变异完的queue，做一层wrapper再写入的时候。</strong></li>
</ul>
</li>
<li>write_to_testcase(out_buf, len)</li>
<li>fault &#x3D; run_target(argv, exec_tmout)</li>
<li>如果fault是FAULT_TMOUT<ul>
<li>如果<code>subseq_tmouts++ &gt; TMOUT_LIMIT</code>（默认250），就将cur_skipped_paths加一，直接返回1</li>
<li>subseq_tmout是连续超时数</li>
</ul>
</li>
<li>否则设置subseq_tmouts为0</li>
<li>如果skip_requested为1<ul>
<li>设置skip_requested为0，然后将cur_skipped_paths加一，直接返回1</li>
</ul>
</li>
<li>queued_discovered +&#x3D; save_if_interesting(argv, out_buf, len, fault)，即如果发现了新的路径才会加一。</li>
<li>如果stage_cur除以stats_update_freq余数是0，或者其加一等于stage_max，就更新展示界面<code>show_stats</code></li>
<li>返回0</li>
</ul>
<h4 id="write-to-testcase"><a href="#write-to-testcase" class="headerlink" title="write_to_testcase"></a>write_to_testcase</h4><p>将从<code>mem</code>中读取<code>len</code>个字节，写入到<code>.cur_input</code>中</p>
<h4 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h4><p>检查这个case的执行结果是否是interesting的，决定是否保存或跳过。如果保存了这个case，则返回1，否则返回0<br>以下分析不包括crash_mode，暂时略过以简洁</p>
<ul>
<li>设置keeping等于0</li>
<li><code>hnb = has_new_bits(virgin_bits)</code>，如果没有新的path发现或者path命中次数相同，就直接返回0</li>
<li>否则，将case保存到<code>fn = alloc_printf(&quot;%s/queue/id:%06u,%s&quot;, out_dir, queued_paths, describe_op(hnb))</code>文件里</li>
<li><code>add_to_queue(fn, len, 0);</code>将其添加到队列里</li>
<li>如果hnb的值是2，代表发现了新path，设置刚刚加入到队列里的queue的has_new_cov字段为1，即<code>queue_top-&gt;has_new_cov = 1</code>，然后queued_with_cov计数器加一</li>
<li>保存hash到其exec_cksum</li>
<li>评估这个queue，<code>calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0)</code></li>
<li>设置keeping值为1.</li>
<li>根据fault结果进入不同的分支<ul>
<li>FAULT_TMOUT<ul>
<li>设置total_tmouts计数器加一</li>
<li>如果unique_hangs的个数超过能保存的最大数量<code>KEEP_UNIQUE_HANG</code>，就直接返回keeping的值</li>
<li>如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整。</li>
<li>如果没有发现新的超时路径，就直接返回keeping</li>
<li>否则，代表发现了新的超时路径，unique_tmouts计数器加一</li>
<li>如果hang_tmout大于exec_tmout，则以hang_tmout为timeout，重新执行一次runt_target<ul>
<li>如果结果为<code>FAULT_CRASH</code>，就跳转到keep_as_crash</li>
<li>如果结果不是<code>FAULT_TMOUT</code>，就返回keeping，否则就使<code>unique_hangs</code>计数器加一，然后更新last_hang_time的值，并保存到<code>alloc_printf(&quot;%s/hangs/id:%06llu,%s&quot;, out_dir, unique_hangs, describe_op(0))</code>文件。</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>total_crashes计数器加一</li>
<li>如果unique_crashes大于能保存的最大数量<code>KEEP_UNIQUE_CRASH</code>即5000，就直接返回keeping的值</li>
<li>同理，如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整</li>
<li>如果没有发现新的crash路径，就直接返回keeping</li>
<li>否则，代表发现了新的crash路径，unique_crashes计数器加一，并将结果保存到<code>alloc_printf(&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;, out_dir,unique_crashes, kill_signal, describe_op(0))</code>文件。</li>
<li>更新last_crash_time和last_crash_execs</li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出异常</li>
</ul>
</li>
<li>对于其他情况，直接返回keeping</li>
</ul>
</li>
</ul>
<h4 id="simplify-trace"><a href="#simplify-trace" class="headerlink" title="simplify_trace"></a>simplify_trace</h4><ul>
<li>按8个字节为一组循环读入，直到完全读取完mem<ul>
<li>如果mem不为空<ul>
<li>i从0-7，<code>mem8[i] = simplify_lookup[mem8[i]]</code>，代表规整该路径的命中次数到指令值，这个路径如果没有命中，就设置为1，如果命中了，就设置为128，即二进制的<code>1000 0000</code></li>
</ul>
</li>
<li>否则设置mem为<code>0x0101010101010101ULL</code>，即代表这8个字节代表的path都没有命中，每个字节的值被置为1。</li>
</ul>
</li>
</ul>
<h2 id="other-function"><a href="#other-function" class="headerlink" title="other function"></a>other function</h2><h3 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h3><ul>
<li><code>int atexit (void (*function) (void));</code>atexit()用来设置一个程序正常结束前调用的函数. 当程序通过调用exit()或从main中返回时, 参数function所指定的函数会先被调用, 然后才真正由exit()结束程序.</li>
<li>如果执行成功则返回0, 否则返回-1, 失败原因存于errno 中.</li>
</ul>
<h3 id="flock"><a href="#flock" class="headerlink" title="flock"></a>flock</h3><ul>
<li><code>int flock(int fd,int operation);</code>flock()会依参数operation所指定的方式对参数fd所指的文件做各种锁定或解除锁定的动作。此函数只能锁定整个文件，无法锁定文件的某一区域。</li>
<li>LOCK_SH 建立共享锁定。多个进程可同时对同一个文件作共享锁定。</li>
<li>LOCK_EX 建立互斥锁定。一个文件同时只有一个互斥锁定。</li>
<li>LOCK_UN 解除文件锁定状态。</li>
<li>LOCK_NB 无法建立锁定时，此操作可不被阻断，马上返回进程。通常与LOCK_SH或LOCK_EX 做OR(|)组合。</li>
<li>单一文件无法同时建立共享锁定和互斥锁定，而当使用dup()或fork()时文件描述词不会继承此种锁定。</li>
<li>返回值 返回0表示成功，若有错误则返回-1，错误代码存于errno。</li>
</ul>
<h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h3><ul>
<li><code>int dup2(int oldfd,int newfd);</code></li>
<li>复制一个现存的文件描述符。当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。dup2和dup的区别就是可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭。如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。</li>
<li>dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。</li>
</ul>
<h3 id="getrlimit-和-setrlimit"><a href="#getrlimit-和-setrlimit" class="headerlink" title="getrlimit 和 setrlimit"></a>getrlimit 和 setrlimit</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nufangrensheng/p/3509262.html">https://www.cnblogs.com/nufangrensheng/p/3509262.html</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/fuzz/" rel="tag"># fuzz</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/c1arkes-head.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#AFL%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">AFL简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.0.1.</span> <span class="nav-text">安装和使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AFL%E5%AE%9E%E6%88%98"><span class="nav-number">2.</span> <span class="nav-text">AFL实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#yaml-cpp-%E9%A1%B9%E7%9B%AE"><span class="nav-number">2.1.</span> <span class="nav-text">yaml-cpp 项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#YAML-%E6%8F%92%E6%A1%A9"><span class="nav-number">2.1.1.</span> <span class="nav-text">YAML 插桩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.2.</span> <span class="nav-text">测试二进制文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-number">2.1.3.</span> <span class="nav-text">高质量的测试用例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8fuzz"><span class="nav-number">2.1.4.</span> <span class="nav-text">启动fuzz</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E5%81%9C%E6%AD%A2%E5%92%8C%E6%95%B4%E7%90%86"><span class="nav-number">2.1.5.</span> <span class="nav-text">何时停止和整理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B"><span class="nav-number">2.1.6.</span> <span class="nav-text">重新开始</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="nav-number">3.</span> <span class="nav-text">AFL源码阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-gcc-c"><span class="nav-number">3.1.</span> <span class="nav-text">afl-gcc.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%AC"><span class="nav-number">3.1.1.</span> <span class="nav-text">调试脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main"><span class="nav-number">3.1.2.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-as"><span class="nav-number">3.1.3.</span> <span class="nav-text">find_as</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params"><span class="nav-number">3.1.4.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execvp"><span class="nav-number">3.1.5.</span> <span class="nav-text">execvp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-as-c"><span class="nav-number">3.2.</span> <span class="nav-text">afl-as.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%AC-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">调试脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-instrumentation"><span class="nav-number">3.2.4.</span> <span class="nav-text">add_instrumentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execvp-1"><span class="nav-number">3.2.5.</span> <span class="nav-text">execvp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trampoline-fmt-64"><span class="nav-number">3.2.6.</span> <span class="nav-text">trampoline_fmt_64</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-payload-64"><span class="nav-number">3.2.7.</span> <span class="nav-text">main_payload_64</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-clang-fast-c"><span class="nav-number">3.3.</span> <span class="nav-text">afl-clang-fast.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#main-2"><span class="nav-number">3.3.1.</span> <span class="nav-text">main</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-llvm-pass-so-cc"><span class="nav-number">3.4.</span> <span class="nav-text">afl-llvm-pass.so.cc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LLVM-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">3.4.1.</span> <span class="nav-text">LLVM 前置知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#register-pass"><span class="nav-number">3.4.2.</span> <span class="nav-text">register pass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runOnModule"><span class="nav-number">3.4.3.</span> <span class="nav-text">runOnModule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.4.4.</span> <span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">源程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E6%8F%92%E6%A1%A9%E7%9A%84IR"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">未插桩的IR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E6%A1%A9%E5%90%8E%E7%9A%84IR"><span class="nav-number">3.4.4.3.</span> <span class="nav-text">插桩后的IR</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-llvm-rt-o-c"><span class="nav-number">3.5.</span> <span class="nav-text">afl-llvm-rt.o.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#deferred-instrumentation"><span class="nav-number">3.5.1.</span> <span class="nav-text">deferred instrumentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#persistent-mode"><span class="nav-number">3.5.2.</span> <span class="nav-text">persistent mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-pc-guard-mode"><span class="nav-number">3.5.3.</span> <span class="nav-text">trace-pc-guard mode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-fuzz-c"><span class="nav-number">3.6.</span> <span class="nav-text">afl-fuzz.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E6%BA%90%E7%A0%81"><span class="nav-number">3.6.1.</span> <span class="nav-text">main源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E6%A0%B8%E5%BF%83%E8%BF%87%E7%A8%8B"><span class="nav-number">3.6.2.</span> <span class="nav-text">main核心过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.3.</span> <span class="nav-text">主要函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-signal-handlers"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">setup_signal_handlers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-shm"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">setup_shm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-dirs-fds"><span class="nav-number">3.6.3.3.</span> <span class="nav-text">setup_dirs_fds</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-testcases"><span class="nav-number">3.6.3.4.</span> <span class="nav-text">read_testcases</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#add-to-queue"><span class="nav-number">3.6.3.5.</span> <span class="nav-text">add_to_queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#load-auto"><span class="nav-number">3.6.3.6.</span> <span class="nav-text">load_auto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#maybe-add-auto"><span class="nav-number">3.6.3.7.</span> <span class="nav-text">maybe_add_auto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pivot-inputs"><span class="nav-number">3.6.3.8.</span> <span class="nav-text">pivot_inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-timeout"><span class="nav-number">3.6.3.9.</span> <span class="nav-text">find_timeout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#perform-dry-run"><span class="nav-number">3.6.3.10.</span> <span class="nav-text">perform_dry_run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#calibrate-case"><span class="nav-number">3.6.3.11.</span> <span class="nav-text">calibrate_case</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E9%83%A8%E5%88%86"><span class="nav-number">3.6.3.11.1.</span> <span class="nav-text">父进程部分</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#has-new-bits"><span class="nav-number">3.6.3.12.</span> <span class="nav-text">has_new_bits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#run-target"><span class="nav-number">3.6.3.13.</span> <span class="nav-text">run_target</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#update-bitmap-score"><span class="nav-number">3.6.3.14.</span> <span class="nav-text">update_bitmap_score</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cull-queue"><span class="nav-number">3.6.3.15.</span> <span class="nav-text">cull_queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mark-as-redundant"><span class="nav-number">3.6.3.16.</span> <span class="nav-text">mark_as_redundant</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzz-one"><span class="nav-number">3.6.3.17.</span> <span class="nav-text">fuzz_one</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CALIBRATION%E9%98%B6%E6%AE%B5"><span class="nav-number">3.6.3.17.1.</span> <span class="nav-text">CALIBRATION阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TRIMMING%E9%98%B6%E6%AE%B5"><span class="nav-number">3.6.3.17.2.</span> <span class="nav-text">TRIMMING阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PERFORMANCE-SCORE%E9%98%B6%E6%AE%B5"><span class="nav-number">3.6.3.17.3.</span> <span class="nav-text">PERFORMANCE SCORE阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SIMPLE-BITFLIP-dictionary-construction-%E9%98%B6%E6%AE%B5"><span class="nav-number">3.6.3.17.4.</span> <span class="nav-text">SIMPLE BITFLIP (+dictionary construction)阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARITHMETIC-INC-x2F-DEC"><span class="nav-number">3.6.3.17.5.</span> <span class="nav-text">ARITHMETIC INC&#x2F;DEC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#INTERESTING-VALUES"><span class="nav-number">3.6.3.17.6.</span> <span class="nav-text">INTERESTING VALUES</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DICTIONARY-STUFF"><span class="nav-number">3.6.3.17.7.</span> <span class="nav-text">DICTIONARY STUFF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RANDOM-HAVOC"><span class="nav-number">3.6.3.17.8.</span> <span class="nav-text">RANDOM HAVOC</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sync-fuzzers"><span class="nav-number">3.6.3.18.</span> <span class="nav-text">sync_fuzzers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trim-case"><span class="nav-number">3.6.3.19.</span> <span class="nav-text">trim_case</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#calculate-score"><span class="nav-number">3.6.3.20.</span> <span class="nav-text">calculate_score</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#common-fuzz-stuff"><span class="nav-number">3.6.3.21.</span> <span class="nav-text">common_fuzz_stuff</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write-to-testcase"><span class="nav-number">3.6.3.22.</span> <span class="nav-text">write_to_testcase</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#save-if-interesting"><span class="nav-number">3.6.3.23.</span> <span class="nav-text">save_if_interesting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#simplify-trace"><span class="nav-number">3.6.3.24.</span> <span class="nav-text">simplify_trace</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#other-function"><span class="nav-number">3.7.</span> <span class="nav-text">other function</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#atexit"><span class="nav-number">3.7.1.</span> <span class="nav-text">atexit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flock"><span class="nav-number">3.7.2.</span> <span class="nav-text">flock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dup2"><span class="nav-number">3.7.3.</span> <span class="nav-text">dup2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getrlimit-%E5%92%8C-setrlimit"><span class="nav-number">3.7.4.</span> <span class="nav-text">getrlimit 和 setrlimit</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">C1arkes</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
